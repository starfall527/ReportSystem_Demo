/***
 * @Author cwx
 * @Description 电机控制
 * @Date 2021-12-08 23:09:36
 * @LastEditTime 2022-08-04 15:20:36
 * @FilePath \IHC_layuiAdmin_Demo\Admin\Manager\canController\motor.js
 * @reference https://github.com/websockets/ws
 */

// todo 目前程序关闭会丢失所有的队列数据,需要设计断点恢复运动的功能

// @note todolist
// todo 考虑将动作组的enqueue部分写入数据库,方便以后调试复数实验

// todo 左右手分别构建队列,设定优先级(左>右)或是为各动作点设置属性:是否暂停另一手的移动
// todo 设定一个左右手管理器,实现多线程,并防撞 (目前评估：优先级低,现有结构足以完成实验)
// todo 补充:这里说的并非技术上的多线程,只需要分开两个队列分别管理左右手即可,内存数据共享
// todo 停顿原因是每个动作点都取了左右手最长完成时间,后面要优化成以动作组为单位,左右手取最长完成时间
// todo 实现思路:在motorMovement入队时拆分左右手,并评估碰撞风险(或者动作点内可写参数,该点之前的动作点自由执行)
// todo 主要改点 更新状态+动作组入列

// * 目前的队列机制能满足基本的控制需求,但要注意：
// * 1.使用ffi查询电机参数会占用一定的处理时间,查询频率过高会影响页面渲染,非必要可不使用


const path = require('path');
const process = require('process');
const macroController = require('../control/macroController.js');
var container = {};
var controller = {};
setTimeout(() => {
    container = require('../control/container.js'); // 这里初始化要有个延时 否则返回{} 原理未知
    controller = container.controller
}, 100);

const pusican = require('./pusican');
const config = require('../../config');
const {
    pusicanMacro
} = require('./pusican');
const logger = require('log4js').getLogger('motor');
const globalLogger = require('log4js').getLogger('globalLogger');
const sqlMacros = require('../../database/macro');
const serial = require('../../serial/serial');
const scan = require('../imgProcess/scan');
const history = require('../historyManager.js');
const edge = require('edge-js');

// #region 变量定义
var motorPointQueue = new macroController.cmdQueueClass();
var motorMovementQueue = new macroController.cmdQueueClass();
var motorTimer = null;
var nodeStatus;
var movementID = 0;

/***
 * @description: 节点相关的一些宏定义
 * @PS {*}
 */
var nodeName = {
    "LEFT_X": 1,
    "LEFT_Y": 2,
    "LEFT_Z": 3,
    "RIGHT_X": 4,
    "RIGHT_Y": 5,
    "RIGHT_Z": 6,
    "HAND": 7,
    "availableNodes": [2],
    "comment": "availableNodes参数代表机器实际使用的节点编号",
    "note": "@note 节点定义"
} //各个电机对应的nodeID


/***
 * @description 运动点坐标 
 * @PS 根据PVT格式写 有些位置需要注意节点运动顺序(先运动到安全点)，以免碰撞
 * @PS 考虑写到config里面,调试用,但用户肯定是不能乱调的
 */
var motorPoints = {}

/***
 * @description 动作组 array 
 */
var motorMovements = {}
var movementStatus = {
    postMovement: { name: '', reagent: '', slideID: -1 },
    currMovement: { name: '', reagent: '', slideID: -1 },
    pumpStatus: {
        reagent: '', // 当前试剂
        volume: 0, // 当前液体量
        maxVolume: 2500, // 柱塞泵最大容量
        tolerance: 150 // 余量,防止试剂进入泵里,影响清洗
    },
}
var blockParams = {
    lastNodeID: 0,
    blockFlag: false,
    lastNodeFlag: false, //确保lastNode开始运动了,才可以根据updateNodeStatus更新blockFlag
    blockData: {},
    operationFlag: false,
    laserFlag: false,
    levelDetectPos: -1,
    // *必须让所有电机都完成运动了,才算完成运动点
}; // 阻塞参数 

/***
 * @description: blockFlag无条件阻塞运动队列
 * @param {*} value
 * @return {*}
 */
function setBlockFlag(value) {
    blockParams.blockFlag = value;
}


/***
 * @description: 查询blockFlag
 * @param {*} value
 * @return {*}
 */
function getBlockFlag(value) {
    return blockParams.blockFlag;
}


/***
 * @description: operationFlag无条件阻塞运动队列
 * @param {*} value
 * @return {*}
 */
function setOperationFlag(value) {
    blockParams.operationFlag = value;
}


/***
 * @description: 查询operationFlag
 * @param {*} value
 * @return {*}
 */
function getOperationFlag(value) {
    return blockParams.operationFlag;
}

// #region @note restfulAPI定义
// const pusicanRest = require('./pusicanRest'); // 暂时没用restfulAPI
var childProcess = require('child_process');
let motorAppPath = path.join(process.cwd(), '/dependencies/motorInit/motorApp.exe');
// let motorAppPath = 'C:/Users/Administrator/Desktop/motorApp/motorApp/bin/x86/Release/netcoreapp3.1/motorApp.exe'
// childProcess.exec(motorAppPath,
//     function (error, stdout, stderr) {
//         if (error) {
//             console.error('error: ' + error);
//             return;
//         }
//         console.log('stdout: ' + stdout); // * 这里就是子进程的console.WriteLine,其实都可以替代websocket了,本质都是非实时通信
//         console.log('stderr: ' + typeof stderr);
//     });

// todo 子进程的打开与ws通信都没啥问题,c#那边对静态方法的使用还不熟,会报错,暂时不用
// 64位库的pp模式设置不了maxSpeed, 看看32位的行不行 (或者检查一下是否设置的时序有要求)



// @note 指令参数定义  规范化动作点和动作组的附加参数
class motorCmdParamClass {
    constructor(cmdType) {
        //私有变量不被外界获取 let
        let queue = [];

        if (cmdType === 'experiment') {

        } else if (cmdType === 'laserSensor') {
            this.laserCheckArray = []
        }
    }
}
// #endregion


// #region edge-js调用pusiDll

const ref = require('ref-napi');
const ffi = require('ffi-napi');
const {
    contain
} = require('jimp');
const ArrayType = require('ref-array-di')(ref);

// @note edge-js 定义引用函数
let dllTestPath = (path.join(process.env.dllPath + '/DllTest.dll')).replace(/\\|\//g, '\\')
// let motorDllTestPath = ('C:/Users/Administrator/Desktop/motorControl/motorControl/bin/Release/motorControl.dll').replace(/\\|\//g, '\\')
let motorDllTestPath = (path.join(process.env.dllPath + '/motorControl.dll')).replace(/\\|\//g, '\\')
// logger.debug(motorDllTestPath)
const SetEventCallback = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'ESetEventCallback'
});
const SetMotorParams = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'ESetMotorParams'
});
const GetNodeStatus = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'EGetNodeStatus'
});
const RunMotorPoint = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'ERunMotorPoint'
});
const ResetPosition = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'EResetPosition'
});
const EInitNodes = edge.func({
    assemblyFile: motorDllTestPath,
    typeName: 'motorControl.Pusican',
    methodName: 'EInitNodes'
});

const byteArray1 = ArrayType(ref.types.byte, 8);
const TestCallback = ffi.Callback('void', ['int', ref.refType(byteArray1), 'int', 'int'],
    function(id, name, data, pLength) {
        logger.warn('id >>' + id);
        logger.warn('name >>' + name);
        // 在这里调用没有用,只能是进行计数
    }); // * 暂时弃用,ffi的callback有问题

// ! 猜测1,ffi需要时间清理重置callback,理由:如果间隔时间5s以上,连续callback就不会报错
// ! 观察1,设置3次callback,时序0-5-6-14,最终在14处报错
// ! 猜测2,ffi需要在偶数次调用callback时,额外调用一次Hello以防止报错,原理未知(补充:不分奇偶,只要每两次callback调用一下就行)
// ! 补充:需要验证其它调用函数的次数是否会影响猜测2 ; 补充:一定时间内(2s内?)调用callback次数不能超过3次,清理溢出的速度由什么决定？
// ! 报错信息主要是 v8::internal::BackingStore::Reallocate 看看如何清理backingStore


// * 排除是dll执行callback的问题,测试dll只用了9ms就调用了,应该还是callback指向的内存位置没有重置
// * 试着重置了callback的内存指向,没有影响
// * 观察,单个电机,定时执行查询,能完成两次callback
// * nodejs版本降到12.18.1,能运行,但是多电机情况下会概率卡在接收callback时,持续2s,电机越多越卡 
// * finish:使用edge-js调用c# dll,需要额外维护motorDll工程,要在那个工程里面维护一定的逻辑
// * PS 目前使用的模式是pp模式,64位的开发库无法设置该模式和速度,ffi无法调用32位的库

/*** @note TPDO回调函数定义
 * @description: TPDO报文回调函数 需在setEventCallback设置
 * @param {*} dwNodeID
 * @param {*} dwTPDOChannel
 * @param {*} data
 * @param {*} dwLen
 * @PS TPDO回调 电机在步进开始时与结束时各发送一次TPDO报文 暂时弃用
 * ! 理论上说,ffi是最有利于编程的实现方案,但是callback拉了,需要再花时间研究
 */
const byteArray = ArrayType(ref.types.uint8, 6);
var TPDOCallback = ffi.Callback('uint32', [ref.types.int32, ref.types.int32, ref.refType(byteArray), ref.types.int32],
    function(dwNodeID, dwTPDOChannel, data, dwLen) {
        let pos = 0;
        for (let i = 0; i < 4; i++) {
            pos += ref.deref(data)[i + 2] * Math.pow(256, i)
            // * uint32型的数据是从低位到高位排列,例如坐标数据为 32,3,0,0 == 32+3*256 == 800
        }
        let callbackData = {
            nodeID: dwNodeID,
            motorStatus: ref.deref(data)[0],
            controlStatus: ref.deref(data)[1],
            position: pos
        };
        updateNodeStatus(callbackData);
        return 0;
    }
);

/*** @note 更新节点状态
 * @description: 更新NodeStatus,该函数为GetNodeStatus的回调函数,触发条件为motorDll中,节点状态发生变化
 * @param {*}
 * @return {*}
 */
function updateNodeStatus(data) {
    if (data !== "") {
        data = JSON.parse(data);
        let nodeID = data.nodeID;
        if (nodeStatus !== undefined) {
            nodeStatus[nodeID].motorParams.motorStatus = data.motorStatus;
            nodeStatus[nodeID].motorParams.controlStatus = data.controlStatus;
            nodeStatus[nodeID].motorParams.position = data.motorPos; // * 从json中读取数据
            let levelResult = -1;
            if (nodeID === 6) {
                // 液位传感器 比较特殊 数据处理假设它挂在6号驱动器上
                if (data.levelDetectPos !== 0 && data.levelDetectPos !== undefined) {
                    blockParams.levelDetectPos = data.levelDetectPos;
                    logger.info(`blockParams.levelDetectPos:${blockParams.levelDetectPos}`);
                    motorConfigJson.levelParams.table.some(element => {
                        if (element[1] - blockParams.levelDetectPos > 0) {
                            levelResult = element[0];
                            return true;
                        }
                    });
                    logger.info(`levelResult:${levelResult}`);
                }
            }
            if (data.blockFlag === 1 || data.blockFlag === 2) {
                nodeStatus[nodeID].motorParams.blockFlag = data.blockFlag;
                blockParams.blockData[nodeID] = data.blockFlag;
            }
            let flag = true;
            Object.values(blockParams.blockData).forEach(element => {
                if (element !== 2) {
                    flag = false;
                }
            }); // * 所有需要运动的电机的controlStatus必须完成0-1-2的转变
            if (flag && !getOperationFlag()) {
                blockParams.lastNodeID = 0;
                blockParams.lastNodeFlag = false;
                motorConfigJson.nodeName.availableNodes.forEach(element => {
                    blockParams.blockData[element] = 0;
                }); // * 重置每个节点的blockData

                if (motorPointQueue.size() === 1) {
                    let element = motorMovementQueue.dequeue();
                    // let element = motorMovementQueue.popElementByProperty('id', motorPointQueue.front().params.movementID)[0];
                    // motorMovementQueue.sortByPriority(1); // 其实只要在pop的时候进行排序,是不需要根据id来出列的,dequeue也够用

                    logger.warn(`动作组完成,${element.name}`);
                    logger.info(element.cmdQueueElement.offset);
                    if (element.name == '转运玻片到玻片仓') {
                        sqlMacros.sqlMultiUpdate({ 'isOccupied': true },
                            'CONTAINER', { 'id': element.cmdQueueElement.offset.slideID }, 'AND');
                        let potPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
                            'type': 'potPoint',
                            'containerID': element.cmdQueueElement.offset.leftPotID,
                        }, 'AND');
                        let rows = global.potCapacity;
                        if (potPoint.length > 0) {
                            let potPointData = JSON.parse(potPoint[0].data);
                            rows = potPointData.rows;
                        }
                        if (element.cmdQueueElement.offset.slideID % rows === 0) { // !注意:该逻辑只在修复盒玻片全转运的前提下才可靠
                            controller.setPotTransportFlag(element.cmdQueueElement.offset.potGroupID, 2);
                        }
                        // * 执行完转运动作后,数据库设置container状态
                    } else if (element.name == '转运玻片到水浴锅') {
                        sqlMacros.sqlMultiUpdate({
                            isOccupied: 'false',
                            status: global.containerStatus.END
                        }, 'CONTAINER', { 'id': element.cmdQueueElement.offset.slideID }, 'AND');
                        sqlMacros.sqlMultiUpdate({ 'isOccupied': true }, 'MOTORPOINT', {
                            type: 'potPoint',
                            containerID: element.cmdQueueElement.offset.leftPotID
                        }, 'AND'); // * 切换POT状态                        
                        logger.info(`转运玻片到水浴锅,偏移量:${element.cmdQueueElement.offset.leftPotID}`);
                        globalLogger.info(`${element.cmdQueueElement.offset.slideID}号仓玻片转运完成,生成运行记录`);
                        history.insertHistory(element.cmdQueueElement.offset.slideID); // * 插入历史记录
                    } else if (element.name == '从玻片仓取出玻片清洗再加液') {
                        global.cmdQueueFlag = 2; // * 电机完成运动,等待后续数据库处理
                        // ! 注意,cmdFinishData.FinishFlag是只属于实验的标志位,转运不包括在内
                    } else if (element.name == '取玻片扫描放回结束') {
                        sqlMacros.sqlMultiUpdate({ 'status': global.containerStatus.WAITING },
                            'POT', { 'id': element.cmdQueueElement.offset.potGroupID }, 'AND'); // * 电机完成运动,等待后续数据库处理
                        controller.setScanLabelFlag(element.cmdQueueElement.offset.potGroupID, true);
                    } else if (element.name == '修复盒关盖') {
                        serial.protocol.sendPackedMsg(element.cmdQueueElement.offset.stepCmd, serial.boards[`board${element.cmdQueueElement.offset.potGroupID}`]); // * 发送串口消息
                    } else if (element.name == '液位检测') {
                        if (levelDetect !== -1) {}
                    } else if (element.name == '从玻片仓取出玻片清洗放回') {
                        sqlMacros.sqlMultiUpdate({
                            'status': global.containerStatus.DABWaiting
                        }, 'CONTAINER', { 'id': element.cmdQueueElement.offset.slideID }, 'AND');
                        logger.info(`${element.cmdQueueElement.offset.slideID}号玻片清洗完成,等待DAB开始`);
                    } else if (element.name == '扫描试剂瓶标签') {
                        controller.setScanLabelFlag(-1, true);
                    }
                    //* 在检测到该动作完成后,dequeue元素 检测方法:所有电机运动完成后触发回调
                    //* 如果dequeue完以后motorPointQueue为空,说明该动作组已经执行完成,这时要把cmdFinishData.FinishFlag设置为3,解除阻塞
                }
                motorPointQueue.dequeue(); // * 先dequeue动作组,再dequeue运动点
                setBlockFlag(false); // * 取消execMotorPoint的阻塞
            }
        }
    }
}
// #endregion

// 电机初始化参数 默认值
// 平时没啥用,读不了config直接报警就完事了,主要还是方便调好了写config,以及在前端显示
// * 根据动作不同,电机会需要不同的细分数/加速度等等,这里要设置若干个模式,载入不同的电机参数
var motorConfigJson = {}
// #endregion

/***
 * @description: MOTORPOINT表定义
 * @field {*}   id              唯一标识    
 * @field {*}   motorPoint      运动点名字
 * @field {*}   data            运动点坐标
 * @field {*}   date            时间戳
 */
const createMotorPointTable = sqlMacros.sqlExecute(`CREATE TABLE IF NOT EXISTS MOTORPOINT(
    id INTEGER not null PRIMARY KEY AUTOINCREMENT ,
    motorPoint VARCHAR(255) NOT NULL,
    type VARCHAR(255),
    containerID INTEGER,
    groupID INTEGER,
    potGroupID INTEGER,
    reagentContainerID INTEGER,
    isOccupied boolean,
    data text ,
    date timestamp NOT NULL default (datetime('now','localtime')) 
    )`);

/*** @note 读取电机config
 * @description: 读取config内motorParams,不需要开放write接口,顺便写入内存motorPoints
 * @param {*}
 * @return {*}
 */
function readMotorConfig() {
    if (config.readConfigFile().motorParams != undefined) {
        // todo 需要检查各参数是否存在
        motorConfigJson = config.readConfigFile().motorParams;
        motorConfigJson.levelParams.table.sort(function(a, b) {
            return a[1] - b[1]; // 对液位表进行排序,由小到大
        });
        motorPoints = motorConfigJson.motorPoints;
        motorMovements = motorConfigJson.movements;
        nodeName = motorConfigJson.nodeName;
        blockParams.blockData = {};
        nodeName.availableNodes.forEach(element => {
            blockParams.blockData[element] = 0;
        });
    } // * 读取config参数到内存中
    sqlMacros.sqlClearTable('MOTORPOINT');
    // * 每次读取motorParams,重新载入MOTORPOINT,这个操作相对花时间

    let motorPointValues = Object.values(motorPoints),
        motorPointKeys = Object.keys(motorPoints),
        setLocationFlag = true; //标记位,检查是否设置成功
    var slidePointBase = [],
        reagentPointBase = [],
        potPointBase = [],
        reagentLabelBase = [];
    motorPointKeys.forEach(motorPoint => {
        if (motorPoint.includes("玻片仓基准点")) {
            slidePointBase = motorPoints[motorPoint];
        } else if (motorPoint.includes("试剂瓶基准点")) {
            reagentPointBase = motorPoints[motorPoint];
        } else if (motorPoint.includes("水浴锅基准点")) {
            potPointBase = motorPoints[motorPoint];
        } else if (motorPoint.includes("试剂瓶拍摄基准点")) {
            reagentLabelBase = motorPoints[motorPoint]; // * 用于进行图像识别,检查水浴锅/复染缸            
        }

    });
    // !注意:这里的识别标准是config文件中的运动点名称,不能乱改

    let sqlStringArray = [],
        sqlValueArray = []; // * sql语句数组,用于批量处理sql操作

    // * 玻片仓基准点
    for (let i = 0; i < slidePointBase.length; i++) {
        for (let j = 0; j < slidePointBase[i].rows; j++) {
            let slidePoint = JSON.parse(JSON.stringify(slidePointBase[i])); // 这里使用深拷贝,否则坐标会错
            let containerID = (slidePointBase[i].groupID - 1) * slidePointBase[i].rows + j + 1;
            let location = [slidePointBase[i].groupID, j];
            let potGroupID = Math.ceil(containerID / global.potCapacity);
            let indexLeftX = slidePoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.LEFT_X;
            });
            let indexLeftZ = slidePoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.LEFT_Z;
            });
            if (indexLeftZ >= 0) {
                slidePoint.name = 'slidePoint' + containerID.toString();
                slidePoint.nodes[indexLeftZ].pos = slidePointBase[i].nodes[indexLeftZ].pos + location[1] * slidePoint.spaceZ; //  获取node为RIGHT_X的元素,并修改其pos
                slidePoint.offsetZ = location[1] * slidePoint.spaceZ; // * Z偏移量
                slidePoint.offsetX = slidePointBase[i].offsetX; // * X偏移量
                // logger.debug(`slidePoint${i}:[${slidePoint.nodes[indexLeftX].pos},${slidePoint.nodes[indexLeftZ].pos}]`);
                sqlStringArray.push(sqlMacros.getSqlInsertString(['motorPoint', 'type', 'containerID', 'groupID',
                        'potGroupID', 'data', 'isOccupied'
                    ],
                    [slidePoint.name, 'slidePoint', containerID, location[0],
                        potGroupID, JSON.stringify(slidePoint), false
                    ], 'MOTORPOINT'));
                sqlValueArray.push({
                    motorPoint: 'slidePoint' + containerID.toString(),
                    data: JSON.stringify(slidePoint)
                })
            } else {
                logger.error('玻片仓基准点未找到可用电机,无法计算坐标')
            }
            // * 在此处计算所有玻片位的坐标,并写入数据库和内存
        }
    }

    // * 试剂瓶基准点
    // todo 1代机和2代机xy对调,干脆在config里面区分两套逻辑
    // #region 1代机xy逻辑
    // for (let i = 0; i < reagentPointBase.length; i++) { // 1代机xy逻辑
    //     for (let j = 0; j < reagentPointBase[i].rows; j++) {
    //         let reagentPoint = JSON.parse(JSON.stringify(reagentPointBase[i])); // 这里使用深拷贝,否则坐标会错
    //         let containerID = (reagentPointBase[i].groupID - 1) * reagentPointBase[i].rows + j + 1;
    //         if (reagentPointBase[i].rows == 8) { // 38位试剂用这个逻辑
    //             containerID = containerID + 6;
    //         }
    //         let location = [reagentPointBase[i].groupID, j];
    //         let indexRightX = reagentPoint.nodes.findIndex(function(element) {
    //             return element.nodeID === nodeName.RIGHT_X;
    //         });
    //         let indexRightY = reagentPoint.nodes.findIndex(function(element) {
    //             return element.nodeID === nodeName.RIGHT_Y;
    //         });

    //         if (indexRightX >= 0 && indexRightY >= 0) {
    //             reagentPoint.name = 'reagentPoint' + containerID.toString();
    //             reagentPoint.nodes[indexRightX].pos = reagentPointBase[i].nodes[indexRightX].pos + location[0] * reagentPoint.spaceX; //  获取node为RIGHT_X的元素,并修改其pos
    //             reagentPoint.nodes[indexRightY].pos = reagentPointBase[i].nodes[indexRightY].pos + location[1] * reagentPoint.spaceY; //  获取node为indexLeftX的元素,并修改其pos
    //             reagentPoint.offsetX = reagentPointBase[i].offsetX; // * 偏移量
    //             reagentPoint.offsetY = location[1] * reagentPoint.spaceY; // * 偏移量
    //             // logger.debug(`reagentPoint${i}:[${reagentPoint.nodes[indexRightX].pos},${reagentPoint.nodes[indexRightY].pos}]`);
    //             sqlStringArray.push(sqlMacros.getSqlInsertString(['motorPoint', 'type', 'containerID', 'groupID', 'data', 'isOccupied'],
    //                 [reagentPoint.name, 'reagentPoint', containerID, location[0], JSON.stringify(reagentPoint), false], 'MOTORPOINT'));
    //             sqlValueArray.push({
    //                 motorPoint: 'reagentPoint' + containerID.toString(),
    //                 data: JSON.stringify(reagentPoint)
    //             })
    //             // * 在此处计算所有试剂瓶的坐标,并写入数据库和内存 
    //         } else {
    //             logger.error('试剂瓶基准点未找到可用电机,无法计算坐标')
    //             setLocationFlag = false;
    //         }
    //     }
    // }
    // #endregion

    // #region 2代机yx逻辑
    for (let i = 0; i < reagentPointBase.length; i++) { // 2代机yx逻辑
        for (let j = 0; j < reagentPointBase[i].rows; j++) {
            let reagentPoint = JSON.parse(JSON.stringify(reagentPointBase[i])); // 这里使用深拷贝,否则坐标会错
            let containerID = (reagentPointBase[i].groupID - 1) * reagentPointBase[i].rows + j + 1;
            if (reagentPointBase[i].rows == 8) { // 38位试剂用这个逻辑
                // containerID = containerID + 6;
            }
            let location = [reagentPointBase[i].groupID, j];
            let indexRightX = reagentPoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.RIGHT_X;
            });
            let indexRightY = reagentPoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.RIGHT_Y;
            });

            if (indexRightX >= 0 && indexRightY >= 0) {
                reagentPoint.name = 'reagentPoint' + containerID.toString();
                reagentPoint.nodes[indexRightX].pos = reagentPointBase[i].nodes[indexRightX].pos + location[0] * reagentPoint.spaceX; //  获取node为RIGHT_X的元素,并修改其pos
                reagentPoint.nodes[indexRightY].pos = reagentPointBase[i].nodes[indexRightY].pos + location[1] * reagentPoint.spaceY; //  获取node为indexLeftX的元素,并修改其pos
                reagentPoint.offsetY = reagentPointBase[i].offsetY; // * 偏移量
                reagentPoint.offsetX = location[1] * reagentPoint.spaceX; // * 偏移量
                // logger.debug(`reagentPoint${i}:[${reagentPoint.nodes[indexRightX].pos},${reagentPoint.nodes[indexRightY].pos}]`);
                sqlStringArray.push(sqlMacros.getSqlInsertString(['motorPoint', 'type', 'containerID', 'groupID', 'data', 'isOccupied'],
                    [reagentPoint.name, 'reagentPoint', containerID, location[0], JSON.stringify(reagentPoint), false], 'MOTORPOINT'));
                sqlValueArray.push({
                    motorPoint: 'reagentPoint' + containerID.toString(),
                    data: JSON.stringify(reagentPoint)
                })
                // * 在此处计算所有试剂瓶的坐标,并写入数据库和内存 
            } else {
                logger.error('试剂瓶基准点未找到可用电机,无法计算坐标')
                setLocationFlag = false;
            }
        }
    }
    // #endregion


    // * 水浴锅基准点
    for (let i = 0; i < potPointBase.length; i++) {
        for (let j = 0; j < potPointBase[i].rows; j++) {
            let potPoint = JSON.parse(JSON.stringify(potPointBase[i])); // 这里使用深拷贝,否则坐标会错
            let containerID = (potPointBase[i].groupID - 1) * potPointBase[i].rows + j + 1;
            let location = [potPointBase[i].groupID, j];
            let indexLeftY = potPoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.LEFT_Y;
            });
            let indexLeftX = potPoint.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.LEFT_X;
            });
            if (indexLeftY >= 0) {
                potPoint.name = 'potPoint' + containerID.toString();
                potPoint.nodes[indexLeftY].pos = potPointBase[i].nodes[indexLeftY].pos + j * potPoint.spaceY; //  获取node为indexLeftX的元素,并修改其pos                

                potPoint.offsetY = potPoint.baseOffsetY + location[1] * potPoint.spaceY; // * Y偏移量
                potPoint.offsetX = potPointBase[i].offsetX; // * X偏移量
                // logger.debug(`potPoint${i}:[${potPoint.nodes[indexLeftY].pos}]`);
                sqlStringArray.push(sqlMacros.getSqlInsertString(['motorPoint', 'type', 'containerID', 'groupID', 'data', 'isOccupied'],
                    [potPoint.name, 'potPoint', containerID, location[0], JSON.stringify(potPoint), false], 'MOTORPOINT'));
                sqlValueArray.push({
                    motorPoint: 'potPoint' + containerID.toString(),
                    data: JSON.stringify(potPoint)
                })
            } else {
                logger.error('水浴锅基准点未找到可用电机,无法计算坐标')
            }
            // * 在此处计算所有玻片位的坐标,并写入数据库和内存 
        }
    }

    // * 试剂瓶图像基准点
    for (let i = 0; i < reagentLabelBase.length; i++) {
        for (let j = 0; j < reagentLabelBase[i].rows; j++) {
            let reagentLabel = JSON.parse(JSON.stringify(reagentLabelBase[i])); // 这里使用深拷贝,否则坐标会错
            let containerID = (reagentLabelBase[i].groupID - 1) * reagentLabelBase[i].rows + j + 1;
            let location = [reagentLabelBase[i].groupID, j];
            let indexRightX = reagentLabel.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.RIGHT_X;
            });
            let indexRightY = reagentLabel.nodes.findIndex(function(element) {
                return element.nodeID === nodeName.RIGHT_Y;
            });

            if (indexRightX >= 0 && indexRightY >= 0) {
                reagentLabel.name = 'reagentLabel' + containerID.toString();
                reagentLabel.nodes[indexRightX].pos = reagentLabelBase[i].nodes[indexRightX].pos + location[0] * reagentLabel.spaceX; //  获取node为RIGHT_X的元素,并修改其pos
                reagentLabel.nodes[indexRightY].pos = reagentLabelBase[i].nodes[indexRightY].pos + location[1] * reagentLabel.spaceY; //  获取node为indexLeftX的元素,并修改其pos
                reagentLabel.offsetX = j * reagentLabel.spaceX; // * X偏移量,groupID是1和2,config里填的spaceX当成offsetX处理,这里的前提是双摄像头
                // logger.debug(`reagentLabelBase${i}:[${reagentLabel.nodes[indexRightX].pos},${reagentLabel.nodes[indexRightY].pos}]`);
                sqlStringArray.push(sqlMacros.getSqlInsertString(['motorPoint', 'type', 'containerID', 'groupID', 'data', 'isOccupied'],
                    [reagentLabel.name, 'reagentLabel', containerID, location[0], JSON.stringify(reagentLabel), false], 'MOTORPOINT'));
                sqlValueArray.push({
                    motorPoint: 'reagentLabel' + containerID.toString(),
                    data: JSON.stringify(reagentLabel)
                })
                // * 在此处计算所有试剂瓶的坐标,并写入数据库和内存 
            } else {
                logger.error('试剂瓶基准点未找到可用电机,无法计算坐标')
                setLocationFlag = false;
            }
        }
    }

    if (setLocationFlag) {
        sqlMacros.sqlTransaction(sqlStringArray);
        logger.debug('插入成功')
    }
    return config.readConfigFile().motorParams;
}


/***
 * @description: 初始化Timer,定时检索运动指令与电机状态,后期element代表动作
 * @param {*}
 * @return {*}
 */
function initMotorTimer() {
    nodeStatus = checkNodeStatus('query');
    let queryFrequency = true;
    if (motorConfigJson.defaultHoming) {
        resetAllMotors();
        openHand();            
    } // * 根据config参数决定是否开机默认回零

    motorTimer = setInterval(() => {
        if (queryFrequency === true) {
            // nodeStatus = checkNodeStatus('query'); // ! 这是直接用ffi查询,实时性高,但会使网页加载变慢
            // queryFrequency = !queryFrequency;
        }
        nodeStatus = checkNodeStatus('check');
        if (nodeStatus.statusCode == 0) { //! 这里的判断条件不应为查询的statusCode,发出指令后同样要改
            execMotorCmd(); // * 执行动作
        }
    }, 200) // * 检索间隔250ms,主要影响动作衔接的顺滑程度,改用回调以后要提高检索频率
}

/***
 * @description: 停止motorTimer,清除interval
 * @param {*}
 * @return {*}
 */
function abortMotorTimer() {
    clearInterval(motorTimer);
    motorTimer = null;
}

/*** @note 电机初始化
 * @description 驱动器及CAN分析仪相关初始化
 * @PS 工作模式设置为位置模式 
 * @TODO:PVT模式中途程序退出的话,电机不会终止运动,必须做外部停止！！
 * @return {*}
 */
function initCAN() {
    readMotorConfig(); //读取config,准备初始化
    SetEventCallback({}); // *这里使用edge进行回调函数设置
    pusican.InitNodes(motorConfigJson.usbcanPort);

    setTimeout(() => {
        for (let i = 0; i < motorConfigJson.InitParams.length; i++) {
            let params = motorConfigJson.InitParams[i];
            setTimeout(() => {
                if (pusican.IsSlaveOnline(params.nodeID) == false) {
                    pusican.startNode(params.nodeID);
                }
            }, 500)
            pusican.startNode(8);
        }
        setTimeout(() => {
            let isAllOnline = true;
            for (let i = 0; i < motorConfigJson.InitParams.length; i++) {
                let params = motorConfigJson.InitParams[i];
                let nodeID = params.nodeID;
                if (nodeName.availableNodes.includes(nodeID)) {
                    if (pusican.IsSlaveOnline(nodeID)) {
                        pusican.setMotorEnable(nodeID, false);
                        pusican.abortStep(nodeID);
                        try {
                            pusican.setMotorEnable(nodeID, true); //中断程序的话必须先disable马达,否则忙状态不清除
                            pusican.setMicroStep(nodeID, parseInt(params.microStep));
                            if (parseInt(params.workMode) <= 3) {
                                pusican.setWorkMode(nodeID, parseInt(params.workMode));
                                pusican.setMaxSpeed(nodeID, parseInt(params.maxSpeed)); // 64位库最大速度设置在pp模式下不生效
                                pusican.setStartSpeed(nodeID, parseInt(params.startSpeed));
                                pusican.setStopSpeed(nodeID, parseInt(params.stopSpeed));
                                pusican.setAccel(nodeID, parseInt(params.accel));
                                pusican.setDecel(nodeID, parseInt(params.decel));
                            } else {
                                SetMotorParams({
                                    nodeID: nodeID,
                                    workMode: params.workMode,
                                    maxSpeed: params.maxSpeed,
                                    startSpeed: params.startSpeed,
                                    stopSpeed: params.stopSpeed,
                                    accel: params.accel,
                                    decel: params.decel,
                                })
                                //* 目前使用c#32位motorApp设置pp模式
                            }
                        } catch (err) {
                            logger.error(err);
                        }
                    } else {
                        isAllOnline = false;
                        logger.error(nodeID + ' is offline')
                    }
                }
            }
            if (isAllOnline && motorTimer == null) {
                initMotorTimer();
                logger.info('motorTimer begin')
            } else {
                logger.error('有节点未上线,请检查连接')
            }
        }, parseInt(motorConfigJson.timerStartDelay)) //启动节点后延时1s设置电机参数
    }, 200) // 先给200ms读取config
}

/*** @note checkNodeStatus
 * @description: 检查总线上各节点/电机/动作点队列/动作组队列状态,并做异常处理
 * @param {*}
 * @return {*}
 * @PS  逻辑是并行检查,有任意异常就返回错误码,逐个排查异常
 */
function checkNodeStatus(mode) { //
    let statusCode = 0,
        NodeStatus = {};
    nodeName.availableNodes.forEach((nodeID) => {
        let nodeParams;
        if (mode === 'query') {
            nodeParams = pusican.getNodeParams(nodeID);
            // GetNodeStatus({
            //     nodeID: nodeID,
            //     type: 'query'
            // }, (err, result) => {
            //     if (err) {
            //         console.log(err);
            //     }
            // });
        } else if (mode === 'check') {
            GetNodeStatus({
                nodeID: nodeID,
                type: 'check'
            }, (err, result) => {
                if (err) {
                    console.log(err);
                }
                updateNodeStatus(result); //调用edge-js查询回调信息
            });
            nodeParams = nodeStatus[nodeID];
        } else if (mode === 'UIcheck') {
            nodeParams = nodeStatus[nodeID];
            if (nodeID === nodeName.HAND) {
                nodeParams.laserSensor = readLaserSensor(nodeID);
            }
        }
        if (nodeParams.isOnline === true) {
            if (nodeParams.motorParams.isEnable == false) {
                statusCode = 12; // * 有电机未启动
            }
            if (nodeParams.motorParams.controlStatus == pusicanMacro.CS_STALL) {
                statusCode = 13; // * 有电机堵转
            }
            if (nodeParams.motorParams.motorStatus > 0) {
                statusCode = 14; // * 有电机错误
            }
            if (nodeParams.motorParams.controlStatus == pusicanMacro.CS_BUSY) {
                statusCode = 18; // * 有电机忙
            }
        } else {
            statusCode = 11; // * 有节点掉线,若查询该节点信息则闪退
        }
        NodeStatus[nodeID] = nodeParams;
    })

    // * 检查动作点队列/动作组队列状态
    if (motorPointQueue.isEmpty() && !motorMovementQueue.isEmpty() && statusCode === 0) {
        // * 动作点队列为空时,从动作组队列中dequeue元素,添加到动作点队列中
        let motorMovementFront = motorMovementQueue.front(),
            movementPoints = motorMovementFront.data;
        motorMovementFront.cmdQueueElement.movementID = motorMovementFront.id;
        for (let i = 0; i < movementPoints.length; i++) {
            enqueueMotorPoint(movementPoints[i], motorMovementFront.cmdQueueElement) // 入队
            // * 根据cmdQueueElement添加偏移量
        }
    }
    NodeStatus.statusCode = statusCode;
    NodeStatus["motorPoint"] = motorPointQueue.isEmpty() ? '' : motorPointQueue.front().data.name;
    NodeStatus["motorMovement"] = motorMovementQueue.isEmpty() ? '' : motorMovementQueue.front().name;
    nodeStatus = NodeStatus;
    return NodeStatus;
}

/***
 * @description: 关闭所有节点和电机
 * @param {*}
 * @return {*}
 */
function closeAllMotors() {
    abortMotorTimer();
    readMotorConfig();
    while (!motorPointQueue.isEmpty()) {
        motorPointQueue.dequeue();

    } // 清空队列
    while (!motorMovementQueue.isEmpty()) {
        motorMovementQueue.dequeue();
    } // 清空队列
    nodeName.availableNodes.forEach((nodeID) => {
        pusican.abortStep(nodeID);
        let nodeParams = pusican.getNodeParams(nodeID);
        if (nodeParams.isOnline) {
            pusican.setMotorPos(nodeParams.motorParams.position);
            setTimeout(() => {
                pusican.setMotorEnable(nodeID, false);
            }, 500)
            // pusican.stopNode(nodeParams.nodeID); //先不关闭节点
        }
    })
    logger.info('关闭所有电机');
}

/***
 * @description: 关闭所有节点和电机
 * @param {*}
 * @return {*}
 */
function startAllMotors() {
    while (!motorPointQueue.isEmpty()) {
        motorPointQueue.dequeue();
    } // 清空队列
    while (!motorMovementQueue.isEmpty()) {
        motorMovementQueue.dequeue();
    } // 清空队列
    nodeName.availableNodes.forEach((nodeID) => {
        let nodeParams = pusican.getNodeParams(nodeID);
        pusican.setMotorEnable(nodeID, true);
    })
    if (motorTimer == null) {
        initMotorTimer();
    }
    logger.info('启动所有电机');
}

/*** @note 运动点入列
 * @description: 电机移动cmd入列  这里是测试单个移动点的函数  
 * @param {*} motorPoint  motorPoints内点的名字
 * @return {*} 是否成功入列
 */
function enqueueMotorPoint(motorPoint, params) {
    let status = false;
    if (motorPoints[motorPoint] != undefined) {
        let element = motorPoints[motorPoint];
        motorPointQueue.enqueue({
            data: element,
            params: params
        }) // 入队
        status = true;
    } else {
        console.log('cannot find motorPoint')
    }
    return status;
}

/*** 动作组入列
 * @description: //@note 动作组入列
 * @param {*} movementName  动作组的名字
 * @param {*} cmdQueueElement  实验有关的数据,生成动作组的offset可以提前在这里分配
 * @return {*} 是否成功入列
 * 动作组需要根据优先级排序,实验超时会提高对应动作组的优先级.因此寻常的dequeue无法满足需求,需要设计id,根据id出列.动作点则保持现状.
 */
function enqueueMotorMovement(movementName, cmdQueueElement) {
    let status = false;
    let movementPoints = [],
        offset;
    if (motorMovements[movementName] !== undefined) {
        movementPoints = motorMovements[movementName].data;
        offset = motorMovements[movementName].offset;
    }
    // todo 需要做一个隐藏动作点的机制,在合适的条件下,去掉部分动作点能有效节省时间
    let paramType;
    if (movementName === 'laserSensor') {
        let potPoints = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'potPoint',
            groupID: cmdQueueElement.groupID
        }, 'AND');
        movementPoints = potPoints.data;
        paramType = 'laserSensor';
        // 将movementPoints替换成potPoints,并附加一个激光的flag
    } else if (['转运玻片到玻片仓', '转运玻片到水浴锅', '取玻片加DAB', '扫描试剂瓶标签',
            '取玻片扫描放回', '取玻片扫描放回结束', '液位检测', '液位检测结束', '从玻片仓取出玻片清洗放回',
            'DAB配液',
        ].includes(movementName)) {
        offset = cmdQueueElement.offset; // * 可以都像这样,特定动作组可以直接分配offset
        paramType = cmdQueueElement.paramType;
    } else if (movementName === '从玻片仓取出玻片清洗再加液') {
        logger.info(`cmdQueueElement.offset` )
        logger.info( cmdQueueElement.offset)
        offset = {
            "leftPotID": 0,
            "rightPotID": 0,
            "reagentID": cmdQueueElement.reagentContainerID,
            "slideID": cmdQueueElement.containerID,
            "washData": cmdQueueElement.washData,
            "injectorWashData": cmdQueueElement.injectorWashData,
            "slideWashData": cmdQueueElement.slideWashData,
            "dose": cmdQueueElement.stepDose
        };
        logger.info(`offset` )
        logger.info( offset)
        cmdQueueElement.offset = offset; // todo 这里很容易弄混,改成以cmdQueueElement.offset为准
        paramType = 'addReagent';
    } else if (movementName === '修复盒开盖' || movementName === '修复盒关盖') {
        offset = {
            stepCmd: cmdQueueElement.stepCmd,
            potGroupID: cmdQueueElement.potGroupID
        };
        cmdQueueElement.offset = offset;
        paramType = 'boxCover';
    } else if (movementName === '液位检测') {
        offset = {
            "leftPotID": 0,
            "rightPotID": 0,
            "reagentID": cmdQueueElement.reagentID,
            "slideID": 0
        };
        cmdQueueElement.offset = offset;
        paramType = 'levelCheck';
    } else {
        paramType = 'experiment';
        cmdQueueElement.offset = offset; // * 以config填写的offset为准
    }
    if (![null, undefined, -1, '', 'null'].includes(cmdQueueElement.offset)) {
        if (![null, undefined, -1].includes(cmdQueueElement.offset.slideID)) {
            movementStatus.currMovement.slideID = cmdQueueElement.offset.slideID; // 全局变量.用于显示机械臂正操作的玻片位置
        } else { movementStatus.currMovement.slideID = -1; }
    }
    if (movementPoints != undefined) {
        movementID = (movementID > 10000000) ? 0 : movementID + 1; // movementID清零
        let element = {
            data: movementPoints,
            name: movementName,
            cmdQueueElement: cmdQueueElement, // 实验附加属性,offset以这里的为准
            paramType: paramType,
            priority: 1, // 优先级属性
            id: movementID // id属性,用于出列
        };
        if (cmdQueueElement.mode !== undefined) { // * 可以通过cmdQueueElement.mode来控制动作组入列的优先级
            if (cmdQueueElement.mode === "unshift") {
                motorMovementQueue.unshift(element);
                // ! unshift目前有问题!有时会导致入队失败
            }
            if (cmdQueueElement.mode === "push") {
                motorMovementQueue.enqueue(element);
            }
        } else {
            motorMovementQueue.enqueue(element);
        }
        logger.warn(`motorMovementQueue.enqueue(${movementPoints})`);
        // * 在实际工作中,动作组中的motorPoint不一定是常量,要根据玻片位的实际坐标运动
        // * 在一个流程中,需要动态计算坐标的motorPoint不止一个,要给一系列的点都添加偏移量,因此需要添加属性来识别
        status = true;
    } else {
        logger.error('cannot find motorMovements')
    }
    return status;
}

/*** @note 执行电机动作
 * @description: 执行电机移动,一组电机移动到指定的坐标点
 * @param {*} nodeID
 * @param {*} position
 * * 动作组的结尾必须是运动点,否则不会dequeue
 */
function execMotorCmd() {
    if (!motorPointQueue.isEmpty()) {
        if (!getBlockFlag() && !getOperationFlag()) {
            setBlockFlag(true); // * 设置阻塞变量,避免其他动作点插队
            let element = JSON.parse(JSON.stringify(motorPointQueue.front().data)), // * 取运动点信息 要从封装好的动作里取 
                params = JSON.parse(JSON.stringify(motorPointQueue.front().params)); // * 传入的辅助参数(偏移量,激光检测等)     
            // * element运动点分为 正常运动(包含纯等待)/等待交互动作(洗针/吸液/加液)
            if (element.type === 'delay') {
                // * 纯等待,设置变量阻塞一下队列,延时结束后清除变量并dequeue
                setTimeout(() => {
                    motorPointQueue.dequeue();
                    logger.debug(`set all delay:${element.delay}`);
                    setBlockFlag(false);
                }, element.delay);
            } else if (element.type === 'operation') {
                // todo 目前有operation和motorPoint伴生的需求了,移动时也要完成operation
                // todo 情景1 移动到开关水浴锅盖的前点时,控制夹手闭合
                // todo 情景2 加液动作组运动同时执行洗针操作,节省时间

                operationProtocol(element, params);
                setTimeout(() => {
                    if (motorPointQueue.size() === 1 && ['试剂瓶图像检测', '玻片二维码检测'].includes(element.name)) {
                        // 洗针这类操作不能放在队尾,否则极容易出现撞针  
                        // todo 操作与下位机交互确认完成,可解除限制
                        motorMovementQueue.dequeue();
                    }
                    motorPointQueue.dequeue();
                    setBlockFlag(false);
                    setOperationFlag(false);
                }, element.delay);
            } // * 等待交互动作(洗针/吸液/加液)
            else if (element.type === 'motorPoint') {
                // todo 激光检测的运动点,需要在解除block的时候进行检测,如需要检测两次,则人为设置block直到检测完成
                // todo 实现方式:在blockParam处添加laserFlag属性,用来标记是否检测完成

                logger.warn(`startMotorStep:${element.name}`);
                for (let i = element.nodes.length - 1; i >= 0; i--) {
                    if (!motorConfigJson.nodeName.availableNodes.includes(element.nodes[i].nodeID)) {
                        element.nodes.splice(i, 1); // * 去掉不可用的节点,availableNodes的优先级最高
                    }
                }
                let offsetElement = addOffset2MotorPoint(element, params, params.offset); // * 根据offset修改element的坐标
                let maxDelay = 0,
                    maxStartDelay = 0; // * maxDelay的含义是单个动作点中,各节点延时的最大值
                let nodeIDArray = [];
                for (let i = 0; i < element.nodes.length; i++) {
                    if (motorConfigJson.nodeName.availableNodes.includes(element.nodes[i].nodeID)) {
                        element.nodes[i].workMode = 4;
                        let delay = parseInt(element.nodes[i].delay);
                        let distance = Math.abs(parseInt(pusican.getMotorPos(element.nodes[i].nodeID)) -
                            parseInt(element.nodes[i].pos));
                        if (distance > 0) {
                            nodeIDArray.push(element.nodes[i].nodeID); // * 记录需要运动的ID,待会排除掉不需要运动的ID
                        } else {
                            blockParams.blockData[element.nodes[i].nodeID] = 2; // * 无需移动的电机,blockData设置为2
                        }
                        delay += (distance /
                            parseInt(element.nodes[i].velocity)) * 1000; // * 先粗略计算哪个是最后完成动作的节点
                        maxDelay = Math.max(maxDelay, delay);
                        if (maxDelay === delay) {
                            maxStartDelay = element.nodes[i].delay;
                            blockParams.lastNodeID = element.nodes[i].nodeID;
                        }
                    }
                }
                for (let i = motorConfigJson.nodeName.availableNodes.length - 1; i >= 0; i--) {
                    if (!nodeIDArray.includes(motorConfigJson.nodeName.availableNodes[i])) {
                        blockParams.blockData[motorConfigJson.nodeName.availableNodes[i]] = 2; // * 不需要运动的电机,blockData设置为2
                        let index = element.nodes.findIndex((e) => {
                            return e.nodeID === motorConfigJson.nodeName.availableNodes[i];
                        })
                        if (index !== -1) {
                            element.nodes.splice(index, 1); // * 如果是不需要运动的电机,则不需要发送给dll
                        }
                    }
                }
                // logger.info(`element.nodes`);
                // logger.info(element.nodes);
                if (element.nodes.length === 0) {
                    let operationBlockTime = 10;
                    if (element.operation !== undefined) {
                        element.operation.forEach(operationElement => {
                            operationBlockTime = Math.max(operationBlockTime, parseInt(operationElement.operationTime));
                            setTimeout(() => {
                                execOperation(operationElement, params);
                            }, operationElement.delay);
                        });
                        if (operationBlockTime != 10) {
                            setOperationFlag(true);
                        }
                    }
                    setTimeout(() => {
                        blockParams.lastNodeID = 0;
                        blockParams.lastNodeFlag = false;
                        //* 在检测到该动作完成后,dequeue元素 检测方法:所有电机运动完成后回调
                        //* 如果dequeue完以后motorPointQueue为空,说明该动作组已经执行完成,这时要把cmdFinishData.FinishFlag设置为3,解除阻塞
                        if (motorPointQueue.size() === 1) {
                            macroController.cmdFinishData.FinishFlag = 2;
                            console.log("no need to run, movement done")
                            motorMovementQueue.dequeue();
                        }
                        motorPointQueue.dequeue(); // * 先dequeue动作组,再dequeue运动点
                        setBlockFlag(false);
                    }, operationBlockTime);
                } else {
                    // if (element.name == "全节点回零前点") {
                    //     element.nodes.forEach(element => { pusican.clearExtStopFlag(element.nodeID, 1); });
                    // }
                    RunMotorPoint({
                        name: element.name,
                        element: JSON.stringify(element.nodes)
                    });
                    if (element.operation !== undefined) {
                        let operationBlockTime = 10;
                        element.operation.forEach(operationElement => {
                            operationBlockTime = Math.max(operationBlockTime, parseInt(operationElement.operationTime));
                            setTimeout(() => {
                                execOperation(operationElement, params);
                            }, operationElement.delay);
                        });
                        if (operationBlockTime != 10) {
                            setOperationFlag(true);
                        }
                    }
                    setTimeout(() => {
                        // logger.info(`set maxStartDelay :${maxStartDelay}`); // 记录最大启动时间
                        blockParams.lastNodeFlag = true; //这里的lastNode,是让getNodeStatus知道谁是最后一个节点,收到lastNode的报文才能说明动作点完成
                    }, maxStartDelay) // * 在最后一个电机开始运动后,允许updateNodeStatus设置blockFlag
                }
            } else if (element.type === 'resetPosition') {
                // * 22/07/30 修复回零后动作组给错误的节点发送指令的bug
                let nodeIDArray = [];
                let activeNode = [];
                let lazyNode = [];
                for (let i = 0; i < element.nodes.length; i++) {
                    if (motorConfigJson.nodeName.availableNodes.includes(element.nodes[i].nodeID)) {
                        if (!readMotorEXT1(element.nodes[i].nodeID)) {
                            nodeIDArray.push(element.nodes[i].nodeID); // * 记录需要运动的ID,待会排除掉不需要运动的ID
                            activeNode.push(element.nodes[i].nodeID);
                        } else {
                            pusican.clearExtStopFlag(element.nodes[i].nodeID, 1);
                            pusican.setMotorPos(element.nodes[i].nodeID, 0);
                        }
                    }
                }
                lazyNode = macroController.differenceSet(motorConfigJson.nodeName.availableNodes, activeNode);
                lazyNode.forEach(element => {
                    blockParams.blockData[element] = 2; // * 不需要运动的电机,blockData设置为2
                });
                for (let i = element.nodes.length - 1; i >= 0; i--) {
                    if (!activeNode.includes(element.nodes[i].nodeID)) {
                        element.nodes.splice(i, 1);
                    }
                }
                logger.info(`reset element.nodes`);
                logger.info(element.nodes);
                if (element.nodes.length > 0) {
                    ResetPosition({
                        name: element.name,
                        element: JSON.stringify(element.nodes)
                    });
                } else {
                    motorConfigJson.nodeName.availableNodes.forEach(element => {
                        blockParams.blockData[element] = 0;
                    }); // * 重置每个节点的blockData
                    motorPointQueue.dequeue(); // * 先dequeue动作组,再dequeue运动点
                    setBlockFlag(false); // * 取消execMotorPoint的阻塞
                }
            }
        }
    }
}

function execOperation(element, params) {
    // * 目前有operation和motorPoint伴生的需求了,移动时也要完成operation
    // * 情景1 移动到开关水浴锅盖的前点时,控制夹手闭合
    // * 情景2 加液动作组运动同时执行洗针操作,节省时间

    operationProtocol(element, params);
    var timer = null;
    let blockDelay = parseInt(element.delay) + parseInt(element.operationTime);
    let operationTime = parseInt(element.operationTime);
    // ! 当操作为吸大量液体时,需要根据吸液量设计operationTime(ax+b模式)
    setTimeout(() => {
        logger.debug(`operation.operationTime:${operationTime}`);
        setOperationFlag(false);
        blockParams.levelFlag = false;
        if (timer !== null) {
            clearInterval(timer);
        }
    }, operationTime);
}

/*** @note 下位机协议
 * @description: 下位机协议
 * @param {*} element
 * @param {*} params
 * @return {*}
 */
function operationProtocol(element, params) {
    // * 一抗- 玻片冲tbs排废液b--钢针冲tbs排废液b
    // * 二抗- 玻片冲tbs排废液b--钢针冲tbs排废液b
    // * dab滴加阶段--玻片冲tbs排废液b--钢针冲tbs排废液a
    // * 第二次dab滴加阶段--玻片冲tbs排废液a--钢针冲tbs排废液a
    // * dab结束转运回修复缸阶段-玻片冲纯水排废液a

    logger.warn(`startOperation:${element.name}`);
    if (element.name === '夹手夹取') {
        closeHand();
    } else if (element.name === '夹手释放') {
        openHand();
    } else if (element.name === '玻片二维码检测') {
        scan.slideQrcode(params.offset.slideID);
    } else if (element.name === '试剂瓶图像检测') {
        scan.reagentLabel(params.offset.reagentLabel);
    } else if (element.name === '激光检测') {
        readLaserSensor();
    } else if (element.name === '洗玻片') {
        // * type 01-纯水排废液A  02-纯水排废液B 03-PBS排废液A  04-PBS排废液B 22/07/29
        params.offset.slideWashData = params.offset.slideWashData === undefined ? 3 : params.offset.slideWashData;
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(4, serial.protocol.washSlideCmd, [params.offset.slideWashData]),
            serial.boards.board4); // * 串口发送洗玻片的指令 粗略设置延时即可 暂不做反馈
    } else if (element.name === '洗针') {
        // * 冲洗类型:00-排空 01-TBS 02-纯水 03-先TBS后纯水
        // * 废液类型:01-废液A 02-废液B  22/08/03
        // params.offset.injectorWashData = params.offset.injectorWashData === undefined ? 1 : params.offset.injectorWashData;
        // let waste = [1].includes(params.offset.injectorWashData.waste) ? 1 : 2; // 1有毒废液 2无毒废液
        let time = params.offset.injectorWashData.time === undefined ? 3 : params.offset.injectorWashData.time; // 首次洗针10秒,后续洗针3秒
        if (![null, undefined, -1, 'null', ''].includes(params.offset.injectorWashTime)) {
            time = Math.ceil(params.offset.injectorWashTime / 100); // 向上取整
        }
        let type = params.offset.injectorWashData.type === undefined ? 1 : params.offset.injectorWashData.type; // 统一用tbs清洗 只有液位检测后用纯水洗
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(5, serial.protocol.washInjectorCmd,
            [type, params.offset.injectorWashData.waste, time]), serial.boards.board5); // * 串口发送洗针的指令
    } else if (element.name === '柱塞泵吸液') {
        params.offset.dose = params.offset.dose === undefined ? 150 : params.offset.dose;
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(5,
                serial.protocol.injectorCmd, [1, 0, params.offset.dose]),
            serial.boards.board5); // * 串口发送柱塞泵吸液的指令,默认加液量为150ul
    } else if (element.name === '柱塞泵排液') {
        params.offset.dose = params.offset.dose === undefined ? 150 : params.offset.dose;
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(5,
                serial.protocol.injectorCmd, [2, 0, params.offset.dose]),
            serial.boards.board5); // * 串口发送柱塞泵排液的指令
    } else if (element.name === '液面检测') {
        // 也可能是上升沿触发 待定
    } else if (element.name === '配液吸液') {
        params.offset.dose = params.offset.dose === undefined ? 1000 : params.offset.dose;
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(5,
                serial.protocol.injectorCmd, [3, 0, params.offset.dose]),
            serial.boards.board5); // * 串口发送柱塞泵吸液的指令,默认加液量为1000ul
    } else if (element.name === '配液排液') {
        params.offset.dose = params.offset.dose === undefined ? 1000 : params.offset.dose;
        serial.protocol.sendPackedMsg(serial.protocol.getCmdStr(5,
                serial.protocol.injectorCmd, [4, 0, params.offset.dose]),
            serial.boards.board5); // * 串口发送柱塞泵排液的指令,默认加液量为1000ul
    }
}

// #region GK96运动封装
// * 该模块用于封装GK96所需运动点
// * 各试剂的坐标点需写入config.json中(调试阶段,最终肯定是存到数据库,避免用户乱改)
// "leftPotPoint":水浴锅
// "slidePoint":玻片仓
// "reagentPoint":试剂位

/*** @note 添加偏移量
 * @description: 为motorPoint添加偏移量
 * @param {*} motorPoint
 * @return {*}
 */
function addOffset2MotorPoint(element, params, offset) {
    let offsetType = element.offsetType === undefined ? [] : element.offsetType;
    if (typeof params !== 'null') {
        logger.warn(params)
    }
    if (offsetType.includes("leftPotPoint") && offset.leftPotID !== undefined) {
        let potPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'potPoint',
            containerID: offset.leftPotID
        }, 'AND');
        if (potPoint.length > 0) {
            let data = JSON.parse(potPoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.LEFT_Y) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetY);
                }
                if (element.nodes[i].nodeID === nodeName.LEFT_X) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetX);
                }
            }
        }
    }
    if (offsetType.includes("rightPotPoint") && offset.rightPotID !== undefined) {
        let potPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'potPoint',
            containerID: offset.rightPotID
        }, 'AND');
        if (potPoint.length > 0) {
            let data = JSON.parse(potPoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.LEFT_Y) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetY);
                }
            }
        }
    }
    if (offsetType.includes("slidePoint") && offset.slideID !== undefined) {
        let slidePoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'slidePoint',
            containerID: offset.slideID
        }, 'AND');
        if (slidePoint.length > 0) {
            let data = JSON.parse(slidePoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.LEFT_Z) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetZ);
                }
                if (element.nodes[i].nodeID === nodeName.LEFT_X) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetX);
                }
            }
        }
        // * 这里根据MOTORPOINT表中的offset来改变坐标
    }
    if (offsetType.includes("addReagentPoint") && offset.slideID !== undefined) {
        let slidePoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'slidePoint',
            containerID: offset.slideID
        }, 'AND');
        if (slidePoint.length > 0) {
            let data = JSON.parse(slidePoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.RIGHT_Z) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) +
                        parseInt(data.offsetZ) * parseFloat(motorConfigJson.ZScaleFactor);
                }
                if (element.nodes[i].nodeID === nodeName.RIGHT_X) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) - parseInt(data.offsetX);
                }
            }
        }
        // * 这里根据MOTORPOINT表中的offset来改变坐标
    }
    if ((offsetType.includes("reagentPoint") && offset.reagentID !== undefined) ||
        (offsetType.includes("reagentPoint2") && offset.reagentID2 !== undefined)) {
        let reagentID = (offsetType.includes("reagentPoint") && offset.reagentID !== undefined) ?
            offset.reagentID : offset.reagentID2;
        let reagentPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'reagentPoint',
            containerID: reagentID
        }, 'AND');
        if (reagentPoint.length > 0) {
            let data = JSON.parse(reagentPoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.RIGHT_X) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetX);
                }
                if (element.nodes[i].nodeID === nodeName.RIGHT_Y) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetY);
                }
            }
        }
    }
    if (offsetType.includes("reagentLabel") && offset.reagentID !== undefined) {
        let reagentPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'reagentLabel',
            containerID: offset.reagentLabel
        }, 'AND');
        if (reagentPoint.length > 0) {
            let data = JSON.parse(reagentPoint[0].data);
            for (let i = 0; i < element.nodes.length; i++) {
                if (element.nodes[i].nodeID === nodeName.RIGHT_X) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetX);
                }
                if (element.nodes[i].nodeID === nodeName.RIGHT_Y) {
                    element.nodes[i].pos = parseInt(element.nodes[i].pos) + parseInt(data.offsetY);
                }
            }
        }
    }
    return element;
}


/*** 全节点归零
 * @description: 全节点归零
 * @param {*}
 * @return {*}
 */
function resetAllMotors() { //@note 全节点归零
    // * 这个回零是使用dll进行回0 核心部分参考例程
    enqueueMotorMovement('全节点回零', {}); // * 要保证config文件中有回零的动作组 可以考虑写入数据库
}

/***
 * @description: 控制夹手打开
 * @param {*}
 * @return {*}
 */
function openHand() {
    //todo 检测夹手状态
    serial.protocol.sendMsg(serial.protocol.handCmd.openHandCmd0);
    setTimeout(() => {
        serial.protocol.sendMsg(serial.protocol.handCmd.openHandCmd1);
    }, 50)
}

/***
 * @description: 控制夹手打开
 * @param {*}
 * @return {*}
 */
function closeHand() {
    //todo 检测夹手状态
    serial.protocol.sendMsg(serial.protocol.handCmd.closeHandCmd0);
    setTimeout(() => {
        serial.protocol.sendMsg(serial.protocol.handCmd.closeHandCmd1);
    }, 50)
}

/*** @note 激光检测玻片
 * @description: 检查水浴锅内的玻片位置
 * @param {*} groupID
 * @return {*}
 */
function getSlidePosition(groupID) {
    // * 思路:每个锅根据基准点计算30个玻片位的坐标(可能根据实际情况修正),依次检查点位是否有玻片,数据库记录isOccupied属性
    let slidePosition = {
        data: []
    };
    let flag = 0; // * 记录传感器输出值
    let potPointList = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
        type: 'pot',
        groupID: groupID
    }, 'AND');
    for (let i = 0; i < potPointList.length; i++) {
        enqueueMotorMovement('laserSensor', {
            groupID: groupID,
            paramType: 'laserSensor'
        });
    }
    // flag = readLaserSensor(parseInt(nodeName.HAND)); // * 读取GPIO状态,固定在7号电机的GPIO
    // // pusican.startRelStep(nodeName.LEFT_X, 30); // * 看是否需要横移,中间点检测到就行的话比较省事
    // flag = flag * readLaserSensor(parseInt(nodeName.HAND)); // * 如果需要横移,则两次检测做乘法,1*1=1,说明玻片摆正
    // if (flag === 1) {
    //     sqlMacros.sqlUpdate('MOTORPOINT', 'isOccupied', 1, 'type', 'pot');
    // }
    return slidePosition;
    //TODO 尝试使用图像处理来识别 水浴锅的玻片位置
}

/*** @note 转运玻片
 * @description: 检查水浴锅内的玻片位置以后,转移到空余的玻片仓中(需要合理分配位置,接入到container表中,预备染色实验)
 * @param {*} potGroupID
 * @param {*} mode      // * 可选值:1.从水浴锅转到玻片仓,2.从玻片仓转到复染缸
 * @return {*}
 */
function transportSlide(potGroupID, mode, slidePoint) {
    if (mode === 1) { // * 从水浴锅转到玻片仓
        let potPointList = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'potPoint',
            groupID: potGroupID,
            // isOccupied: 'false' // * 这里注释掉的原因是,即使扫描失败的玻片也会被转移到玻片仓中
        }, 'AND');
        let slide = sqlMacros.sqlQuery('*', 'CONTAINER', {
            potGroupID: potGroupID,
            // isOccupied: 'false' // * 这里注释掉的原因是,即使扫描失败的玻片也会被转移到玻片仓中
        }, 'AND');

        // * 选取水浴锅内的玻片位置,转运到未被占用的玻片仓,CONTAINER表记录isOccupied属性
        for (let i = 0; i < potPointList.length; i++) {
            enqueueMotorMovement('转运玻片到玻片仓', {
                potGroupID: potGroupID,
                paramType: 'transport',
                offset: {
                    "leftPotID": potPointList[i].containerID,
                    "rightPotID": 0,
                    "reagentID": 0,
                    "slideID": slide[i].id,
                    "potGroupID": potGroupID,
                    slideWashData: 3
                }
            }); // 需要补充设置offset
        }
        if (potPointList.length === 0) {
            logger.warn('没有玻片处于完成状态,无法转运');
        }
        //TODO 尝试使用图像处理来识别 水浴锅的玻片位置
        // * 目前的逻辑是: 运动到motorPoint,夹取(需要力反馈,还没做),若夹取不到,则退出该次转运,进行下一次转运;
    } else if (mode === 2) { // * 从玻片仓转到修复缸
        let potPointList = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
            type: 'potPoint',
            groupID: potGroupID,
            isOccupied: 'false'
        }, 'AND');
        if (potPointList.length === 0) {
            logger.error('复染缸无空余位置,无法转运');
        } else if (slidePoint === undefined) {
            logger.error('玻片转运点未定义,无法转运');
        } else {
            enqueueMotorMovement('转运玻片到水浴锅', {
                paramType: 'transport',
                offset: {
                    "leftPotID": potPointList[0].containerID, // 偏移量的范围是1-30
                    "rightPotID": 0,
                    "reagentID": 0,
                    "slideID": slidePoint.id,
                    "potGroupID": potGroupID,
                }
            }); // 需要补充设置offset
            sqlMacros.sqlMultiUpdate({ isOccupied: 'true' }, 'MOTORPOINT', {
                containerID: potPointList[0].containerID,
                type: 'potPoint',
                groupID: potGroupID,
            }, 'AND');
        }
    } else if (mode === 3) { // * 从玻片仓清洗,放回玻片仓,二抗与DAB之间使用
        enqueueMotorMovement('清洗玻片放回玻片仓', {
            paramType: 'transport',
            offset: {
                "leftPotID": 0,
                "rightPotID": 0,
                "reagentID": 0,
                "slideID": slidePoint.id,
                "potGroupID": potGroupID,
            }
        }); // 需要补充设置offset
    }
}


/*** @note 修复前扫描玻片
 * @description: 检查水浴锅内的玻片位置以后,转移到空余的玻片仓中(需要合理分配位置,接入到container表中,预备染色实验)
 * @param {*} potGroupID
 * @return {*}
 */
function scanPotSlide(potGroupID) {
    let potPointList = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
        type: 'potPoint',
        groupID: potGroupID,
        isOccupied: 'false'
    }, 'AND');
    let container = sqlMacros.sqlQuery('*', 'CONTAINER', {
        status: global.containerStatus.AVAILABLE,
        potGroupID: potGroupID,
        isOccupied: 'false'
    }, 'AND');
    if (container.length > 0) {} else {}
    // * 选取水浴锅内的玻片位置,拿起拍二维码再放下
    enqueueMotorMovement('取玻片扫描放回起始', {}); // 需要补充设置offset
    for (let i = 0; i < potPointList.length; i++) {
        enqueueMotorMovement('取玻片扫描放回', {
            potGroupID: potGroupID,
            paramType: 'transport',
            offset: {
                "leftPotID": potPointList[i].containerID,
                "rightPotID": 0,
                "reagentID": 0,
                "slideID": container[i].id
            }
        }); // 需要补充设置offset
    }
    enqueueMotorMovement('取玻片扫描放回结束', {
        offset: {
            "potGroupID": potGroupID
        }
    }); // 需要补充设置offset

    if (potPointList.length === 0) {
        logger.warn('没有玻片处于完成状态,无法转运');
    }
}

/*** @note 扫描试剂瓶标签
 * @description: 扫描试剂瓶标签
 * @param {*}
 * @return {*}
 */
function scanReagentLabel() {
    let reagentLabelList = sqlMacros.sqlQuery('*', 'MOTORPOINT', {
        type: 'reagentLabel',
        isOccupied: 'false'
    }, 'AND');
    for (let i = 0; i < reagentLabelList.length; i++) {
        enqueueMotorMovement('扫描试剂瓶标签', {
            paramType: 'scan',
            offset: {
                "leftPotID": 0,
                "rightPotID": 0,
                "reagentID": 0,
                "slideID": 0,
                "reagentLabel": reagentLabelList[i].containerID
            }
        }); // 需要补充设置offset
    }
    if (reagentLabelList.length === 0) {
        logger.warn('未找到识别基准点,无法识别试剂瓶');
    } else {
        enqueueMotorMovement('试剂瓶扫码回零', {});
    }
    //TODO 尝试使用图像处理来识别 水浴锅的玻片位置
}


/*** @note 液位检测
 * @description: 液位检测
 * @param {*}
 * @return {*}
 */
function levelDetect() {
    // ! 目前的液位检测 受速度与查询延迟影响,查询位置并不准确
    // ! 通过实测倒推液位行程表,但需要在保证稳定的前提下进行
    // ! 且当前x64的库无法设置电机加速度,实际动作点很难进行变速 预计在使用restfulAPI后将得到改善(希望32位库可以设置变速)
    let reagentPoint = sqlMacros.sqlQuery('*', 'MOTORPOINT', { type: 'reagentPoint' }, 'AND');
    for (let i = 0; i < reagentPoint.length; i++) {
        enqueueMotorMovement('液位检测', {
            paramType: '液位检测',
            offset: {
                "reagentID": reagentPoint[i].containerID,
            }
        }); // 需要补充设置offset

    }
    if (reagentPoint.length === 0) {
        logger.warn('未找到基准点,无法检测试剂瓶液位');
    }
    enqueueMotorMovement('液位检测结束', {});
}

/***
 * @description: 读取GPIO状态,固定在7号电机的GPIO 目前激光传感器只改变GPIO8的值 遮住返回1,未遮住返回0
 */
function readLaserSensor(nodeID) {
    let value = -1;
    value = pusican.getGPIOValue(nodeID);
    value = value % 4096;
    let G8 = (value - (value % 2048)) / 2048;
    G8 = !G8;
    return G8;
}


/***
 * @description: 读取紧急停止位1 用于判断是否需要回零 遮住返回1,未遮住返回0
 */
function readMotorEXT1(nodeID) {
    let value = -1;
    value = pusican.getGPIOValue(nodeID);
    value = value % 256;
    let G8 = Math.floor((value - (value % 128)) / 128);
    return G8 === 0;
}

/***
 * @description: 获取液位传感器状态,0/1 对应 未检测到液位/检测到液位 结果放在blockData.levelFlag内
 */
function getLevelSensor() {

}


// #region DAB配液
/***
 * @description: @note 配制DAB试剂
 * @return {*}
 */
function dispenseDAB(ratio, DABDose) {
    let originDose = DABDose * ratio;
    let diluentDose = DABDose - originDose;
    // 动作套组
    let diluent = sqlMacros.sqlQuery('*', 'REAGENTCONTAINER', { reagentName: 'DAB稀释液' }, 'AND');
    let origin = sqlMacros.sqlQuery('*', 'REAGENTCONTAINER', { reagentName: 'DAB原液' }, 'AND');
    let DAB = sqlMacros.sqlQuery('*', 'REAGENTCONTAINER', { reagentName: 'DAB' }, 'AND');
    if (diluent.length > 0 && origin.length > 0) {
        enqueueMotorMovement("DAB配液", {
            offset: {
                slideID: 0,
                reagentID: diluent[0].id,
                reagentID2: DAB[0].id,
                dose: diluentDose, // 剂量要考虑泵容量
            }
        });
        enqueueMotorMovement("DAB配液", {
            offset: {
                slideID: 0,
                reagentID: origin[0].id,
                reagentID2: DAB[0].id,
                dose: originDose, // 剂量要考虑泵容量
            }
        });
    } else {}
}
// #endregion


// #region 重复动作测试

/*** @note 重复动作测试
 * @description: 重复动作测试 在config.json中设置要测试的动作组,执行次数等
 */
function motorTest() {
    if (motorConfigJson.testParams !== undefined) {
        let repeatCount = motorConfigJson.testParams.repeatCount,
            count = 0,
            flag = true,
            pos = 2000;
        let testMovement = motorConfigJson.testParams.movementName;
        let offsetRange = motorConfigJson.testParams.offsetRange;
        motorMovements[testMovement].offset = {};
        let timer = setInterval(() => {
            if (motorMovementQueue.size() === 0 && flag && nodeStatus.statusCode === 0) {
                let params = '';
                if (testMovement === '转运玻片到玻片仓') {
                    transportSlide(1, 1);
                } else if (testMovement === '转运玻片到水浴锅') {
                    transportSlide(1, 2);
                } else if (testMovement === '扫描试剂瓶标签') {
                    scanReagentLabel();
                } else if (testMovement === '取玻片扫描放回-套组') {
                    scanPotSlide(1);
                } else if (testMovement === '液位检测-套组') {
                    levelDetect();
                } else if (testMovement === '液位检测-套组') {
                    levelDetect();
                } else if (testMovement === 'DAB配液') {
                    dispenseDAB(1 / 20, 2000);
                } else {
                    if (Object.keys(offsetRange).includes("leftPotID")) {
                        if (motorMovements[testMovement].offset.leftPotID >= offsetRange.leftPotID[1] ||
                            motorMovements[testMovement].offset.leftPotID === undefined) {
                            motorMovements[testMovement].offset.leftPotID = offsetRange.leftPotID[0];
                        } else {
                            motorMovements[testMovement].offset.leftPotID += 1;
                        }

                    }
                    if (Object.keys(offsetRange).includes("slideID")) {
                        if (motorMovements[testMovement].offset.slideID >= offsetRange.slideID[1] ||
                            motorMovements[testMovement].offset.slideID === undefined) {
                            motorMovements[testMovement].offset.slideID = offsetRange.slideID[0];
                        } else {
                            motorMovements[testMovement].offset.slideID += 1;
                        }
                    }
                    enqueueMotorMovement(testMovement, {
                        paramType: params,
                        offset: motorMovements[testMovement].offset
                    });
                }
                count++;
                if (count % 30 === 29) { // 执行套组时,每30次套组执行一次复位
                    resetAllMotors();
                }
                logger.info(`已完成动作组 ${testMovement}:执行第${count-1}次`);
                // pos = (count % 2 === 0) ? 2000 : 4000;
            }
            if (count >= parseInt(repeatCount)) {
                clearInterval(timer);
                timer = null;
                console.log('测试已完成')
                console.log(`已执行动作组:${count}次`);
                flag = false;
            }
            if (nodeStatus.statusCode !== 0 && nodeStatus.statusCode !== 18) {
                clearInterval(timer);
                timer = null;
                console.error('检测到电机异常,测试终止');
                console.log(`已执行动作组:${count}次`);
            }
        }, motorConfigJson.testParams.interval)
    } else {
        console.error('未设置测试参数')
    }
}
// #endregion

// #endregion

// #region @note 调试区
initCAN(); // * 使用motorApp进行初始化,需要让ffi等待3秒再启动定时器


// 动作组出列测试
// let a = [5, 3, 3, 4, 2, 1, 3, 2, 6, 1, 2]
// for (let i = 0; i < 5; i++) {
//     movementID = (movementID > 10000000) ? 0 : movementID + 1; // movementID清零
//     motorMovementQueue.enqueue({
//         data: 1,
//         name: 1,
//         cmdQueueElement: 1,
//         offset: 1,
//         paramType: 1,
//         priority: a[i],
//         id: movementID
//     });
//     // motorMovementQueue.sortByPriority(1); // 根据优先级排序
//     // motorMovementQueue.popElementByProperty('id', 3); // 排出指定id的动作组
//     // motorMovementQueue.popElementByProperty('id', 5);
// }
// console.log(motorMovementQueue.getQueue())

// 难题 restful方式实时性始终无法和直接调用dll相比 调查询类函数很难直接用返回结果来做逻辑判断
// 解决方案1:查询类逻辑全部写到c#那边 (包括激光传感器,运动回调状态)
// pusicanRest.initNodes();

process.on('exit', (code) => {
    // * 记录本次运动数量
    logger.info(`本次运行共执行动作组${movementID}次`);
    console.log(`About to exit with code: ${code}`);
    closeAllMotors();
});

module.exports = {
    motorConfigJson,
    motorPoints,
    motorMovements,
    motorPointQueue,
    motorMovementQueue,
    nodeStatus,
    enqueueMotorPoint,
    enqueueMotorMovement,
    checkNodeStatus,
    initCAN,
    closeAllMotors,
    startAllMotors,
    resetAllMotors,
    initMotorTimer,
    abortMotorTimer,
    readMotorConfig,

    // * 动作套组
    transportSlide, // 转运玻片
    scanReagentLabel, //扫描试剂瓶标签
    scanPotSlide, //取玻片扫描标签再放回
    levelDetect, // 液位检测
    dispenseDAB, // dab配液

    openHand,
    closeHand,

    motorTest,

    //阻塞相关
    getBlockFlag,
    getOperationFlag,
    blockParams,
    movementStatus
};