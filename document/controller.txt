/***
 * @Author cwx
 * @Description 实验交互流程控制
 * @Date 2021-11-08 11:01:54
 * @LastEditTime 2022-08-04 15:18:28
 * @FilePath \IHC_layuiAdmin_Demo\Admin\Manager\control\controller.js
 */

const sqlMacros = require("../../database/macro");
var serial = require('../../serial/serial.js');
var macroController = require('./macroController');
var motor = require('../canController/motor')
const logger = require('log4js').getLogger('controller');
const globalLogger = require('log4js').getLogger('globalLogger');
const config = require('../../config.js');

// ! 待解决bug:漏指令/暂停运动/钢针偏移
// ! 夹手漏发指令导致玻片未放入玻片仓,碰撞后7号电机释放锁轴

// todo 需要拆分逻辑, 单独完成修复/单独完成孵育/单独进行复染

// * 扫描玻片失败逻辑
// * 实时窗口表格标红,在抗原修复结束前允许用户编辑该玻片位
// * 整体实验结束后,是否清除该玻片的标红,并转运回修复盒?

var {
    cmdFinishFlag,
} = require('./macroController');

// ! 所有的标志位都可以放在global那里,避免赋值出错
global.cmdQueueFlag = 1 // 定义cmdQueueFlag全局变量,用于checkSlideStatus检查孵育实验状态

var cmdQueue = new macroController.cmdQueueClass(); //玻片位队列

function editCmdElementByID(property, value, containerID) {
    return cmdQueue.editElementPropertyByID(property, value, containerID)
}

function findCmdElement(property, value) {
    return cmdQueue.findElementByProperty(property, value)
}

process.on('exit', (code) => {
    logger.warn(`About to exit with code: ${code}`);
});

var controlFlag = {
    allTransportFlag: 0,
    highestFlag: false,
    maxPriority: 6,
    pot: {
        1: {
            isEnabled: false, //todo 是否启用修复缸,用于逻辑判断,目前很多时候只启动1个修复缸是没法完成实验的,宏观control要改
            transportFlag: 0, // 0/1/2/3 未执行/执行中/转运到玻片仓执行完成/转运回修复缸完成
            scanLabelFlag: false,
            slideCount: 0
        },
        2: {
            isEnabled: false,
            transportFlag: 0, // 0/1/2/3 未执行/执行中/转运到玻片仓执行完成/转运回修复缸完成
            scanLabelFlag: false,
            slideCount: 0
        },
        3: {
            isEnabled: false,
            transportFlag: 0, // 0/1/2/3 未执行/执行中/转运到玻片仓执行完成/转运回修复缸完成
            scanLabelFlag: false,
            slideCount: 0
        }
    },
    scanReagentLabelFlag: false,
    repairFlag: false,
    incubationFlag: false,
};

/***
 * @description: 无条件阻塞实验
 * @param {*} value
 * @return {*}
 */
function setControlFlag(value) {
    // 这是强制停止实验 无法检测正在反应的各仓状态
    controlFlag.highestFlag = value; //true时执行实验
}

/***
 * @description: 设置修复盒是否启用
 * @param {*} value
 * @return {*}
 */
function setPotEnableFlag(potGroupID, value) {
    // 这是强制停止实验 无法检测正在反应的各仓状态
    controlFlag.pot[potGroupID].isEnabled = value; // true时执行实验
}

/***
 * @description: 设置转运标志位
 * @param {*} potGroupID
 * @param {*} value
 * @return {*}
 */
function setPotTransportFlag(potGroupID, value) {
    if (potGroupID === -1) {
        controlFlag.allTransportFlag = value;
    } else {
        controlFlag.pot[potGroupID].transportFlag = value;
    }
    logger.info(`setPotTransportFlag: ${potGroupID}, ${value}`);
}
/***
 * @description: 设置扫描玻片二维码的标志位
 * @param {*} value
 * @return {*}
 */
function setScanLabelFlag(potGroupID, value) {
    if (potGroupID === -1) {
        controlFlag.scanReagentLabelFlag = value; // 试剂瓶标签
    } else {
        controlFlag.pot[potGroupID].scanLabelFlag = value;
    }
    logger.info(`setScanLabelFlag: ${potGroupID}, ${value}`);
}

// @note 宏观流程控制
const statusTimer = setInterval(() => {
    if (controlFlag.highestFlag) {
        let enabledPot = [];
        for (let i = 1; i <= Object.keys(controlFlag.pot).length; i++) {
            if (controlFlag.pot[i].isEnabled) { enabledPot.push(i) }
        }
        enabledPot = enabledPot.length === 0 ? -1 : enabledPot;
        let pot = sqlMacros.sqlQuery('*', 'POT', { id: enabledPot }, 'AND');
        let container = sqlMacros.sqlQuery('*', 'CONTAINER', { potGroupID: enabledPot }, 'AND');
        let reagentContainer = sqlMacros.sqlSelect('*', 'REAGENTCONTAINER');

        // let pot = sqlMacros.sqlSelect('*', 'POT', true, 'type', 'pot'); // * 修复盒
        // let container = sqlMacros.sqlSelect('*', 'CONTAINER', true, 'type', 'slide'); // * 玻片仓
        let potPoint = sqlMacros.sqlSelect('*', 'MOTORPOINT', true, 'type', 'potPoint'); // * 水浴锅运动点
        let slidePoint = sqlMacros.sqlSelect('*', 'MOTORPOINT', true, 'type', 'slidePoint'); // * 玻片仓运动点
        let skipStainingFlag = config.readConfigFile().experimentParams.skipStainingFlag; // 减少性能消耗可移到外面去
        // * 如果想禁用某个修复盒,在startAll时设置标志位,在这里删去响应的pot和container就行
        // * 这样要保证该函数内所有的pot和container数据都来源于此,逻辑上要统一
        // ! 有逻辑漏洞,在开始实验后,再次编辑修复盒并开始实验的话,allTransportFlag并不能与新加入的修复盒对应,导致实验无法进行

        checkPotStatus(pot); // * 1阶段 进行抗原修复实验
        // ! 本机是在抗原修复后再转运玻片并统计试剂种类及余量,若存在试剂种类不足的情况该如何处理?
        if (!controlFlag.scanReagentLabelFlag && enabledPot != -1) {
            motor.scanReagentLabel(); // 扫描试剂标签
            controller.setScanLabelFlag(-1, true);
        }
        pot.forEach(element => {
            if (controlFlag.pot[element.id].scanLabelFlag) {}
            if (element.status == containerStatus.FINISH) {
                motor.transportSlide(element.id, 1);
                sqlMacros.sqlMultiUpdate({ 'status': containerStatus.TRANSPORT }, 'POT', { 'id': element.id });
                // * 2阶段 抗原修复完成 检查各水浴锅的isOccupied属性 满足条件则进行转运到玻片仓
                // todo 方案1 转运的优先级低于孵化实验,即是转运一片后立即进行这片的加液实验(否决,因为需要计算试剂总消耗量)
                // todo 方案2 转运的优先级高于孵化实验,全体转运完成后,再根据各玻片的总耗时(以及加液便利程度)进行排序
            }
        });
        // 转运阶段,目前染色测试时间长,暂时先分割逻辑

        if (controlFlag.allTransportFlag === 0) {
            let allDone = true;
            pot.forEach(element => {
                if (controlFlag.pot[element.id].transportFlag !== 2) {
                    allDone = false; // * 需要全部修复缸都完成转运,才进行孵育
                    // 该逻辑的目的是方便统计试剂总的消耗量,缺点是不够灵活(第四个玻片架进入时不会启动修复)
                } // console.log(!config.readConfigFile().experimentParams.skipIncubationFlag)
                if (allDone) {
                    if (!config.readConfigFile().experimentParams.skipIncubationFlag) {
                        setPotTransportFlag(-1, 2);
                        let reagentCost = getReagentCost(container, reagentContainer);
                    } else {
                        setPotTransportFlag(-1, 4);
                        setPotTransportFlag(element.id, 5); //跳过孵化与复染,停止实验
                    }
                } // 这种allDone的写法有致命缺陷,不能更改任意一个修复缸的状态
            })
        }
        if (controlFlag.allTransportFlag === 2) {
            checkSlideStatus(container, pot); // * 3阶段 进行孵化染色实验
            let transportSlideCount = [];
            pot.forEach(element => {
                transportSlideCount.push({ potID: element.id, count: 0, dabCount: 0 });
                if (controller.controlFlag.pot[element.id].slideCount === 0) { // 只计算一次
                    let count = 0;
                    container.forEach(containerElement => {
                        if (containerElement.experimentID !== -1 &&
                            containerElement.potGroupID === element.id) { count++; } // * 统计各仓处于FINISH状态的玻片数量
                    })
                    controller.controlFlag.pot[element.id].slideCount = count;
                }
            });
            let dabStartFlag = true;
            container.forEach(element => {
                // * dab实验检测,完成后自动切换到FINISH,放回玻片架
                if (element.status == containerStatus.FINISH) {
                    motor.transportSlide(element.potGroupID, 2, element);
                    sqlMacros.sqlMultiUpdate({ 'status': containerStatus.TRANSPORT },
                        'CONTAINER', { 'id': element.id });
                    // * 4阶段 孵化染色实验完成 检查各玻片位的isOccupied属性 满足条件则进行转运到修复缸
                }
                for (let i = 1; i <= pot.length; i++) {
                    if (element.potGroupID === i) {
                        if (element.status == containerStatus.END) {
                            transportSlideCount[i - 1].count++;
                        } // * 统计各修复缸转运完成的玻片数
                        if (element.status == containerStatus.DABWaiting) {
                            transportSlideCount[i - 1].dabCount++;
                        } // * 统计各修复缸转运完成的玻片数
                        // ! 根据此逻辑,信息录入失败的玻片,需要再执行转运到修复缸,并把status设置为END(还没实现)
                    }
                }
                if (element.status == containerStatus.WASH || element.status == containerStatus.BUSY) {
                    dabStartFlag = false;
                }
            });
            transportSlideCount.forEach(element => {
                if (element.count === controlFlag.pot[element.potID].slideCount && pot[element.potID - 1].status !== containerStatus.END) {
                    sqlMacros.sqlMultiUpdate({ 'status': containerStatus.END }, 'POT', { 'id': element.potID });
                    globalLogger.info(`${element.potID}号玻片架完成所有实验,请收片`);
                    setPotTransportFlag(element.potID, 3);
                    // * 该修复缸所有玻片转运完成 可提示用户收片
                }
                if (element.dabCount === controlFlag.pot[element.potID].slideCount && dabStartFlag) {
                    container.forEach(element => {
                        if (element.status === containerStatus.DABWaiting) {
                            sqlMacros.sqlMultiUpdate({ 'status': containerStatus.WAITING },
                                'CONTAINER', { 'id': element.id });
                        } // 启动DAB实验
                    });
                    // motor.enqueueMotorMovement('洗针后回零点', { mode: "unshift" }); // ! 一吸多分才使用
                    globalLogger.info(`${element.potID}号玻片架开始DAB实验`);
                }
            });
            let allDone = true;
            pot.forEach(element => {
                if (controlFlag.pot[element.id].transportFlag !== 3) {
                    allDone = false; // * 需要全部修复缸都完成转运,才进行复染判断
                }
            })
            if (allDone) {
                setPotTransportFlag(-1, 3);
                globalLogger.info(`所有玻片架完成所有转运,进行复染检查`);
            }
        }
        if (controlFlag.allTransportFlag === 3) {
            for (let i = 0; i < pot.length; i++) { // * 复染判断                
                if (pot[i].status === containerStatus.END &&
                    ![null, undefined, ''].includes(pot[i].stainingConfig) && !skipStainingFlag) {
                    let experiment = sqlMacros.sqlQuery('*', 'EXPERIMENT', {
                        experimentType: '复染',
                        experimentName: pot[i].stainingConfig
                    }, 'AND');
                    if (experiment.length > 0) {
                        sqlMacros.sqlMultiUpdate({
                            status: containerStatus.WAITING,
                            sequence: 1,
                            experimentID: experiment.experimentID,
                            experimentName: experiment.experimentName,
                        }, 'POT', { 'id': pot[i].id }); // * 启动复染实验
                    }
                } else if (pot[i].stainingConfig === '' && controlFlag.pot[pot[i].id].transportFlag !== 4) {
                    setPotTransportFlag(pot[i].id, 5);
                } else if (skipStainingFlag) { setPotTransportFlag(pot[i].id, 4); }
            }
            setPotTransportFlag(-1, 4);
        }
        if (controlFlag.allTransportFlag === 4) {
            let allDone = true;
            pot.forEach(element => {
                if (controlFlag.pot[element.id].transportFlag !== 5) {
                    allDone = false; // * 需要全部修复缸都完成转运,才进行复染判断
                }
            })
            console.log(pot);
            if (allDone || skipStainingFlag) {
                pot.forEach(element => {
                    let cmdStr = serial.protocol.getCmdStr(element.id, serial.protocol.setContainerStatusCmd,
                        [0, serial.prefixInteger(3, 2), 0, 0, 0]);
                        logger.info(`cmdStr = ${cmdStr}`);
                    // serial.sendPackedMsg(cmdStr, serial.boards[`board${element.id}`]);
                    // 发送一次排液指令
                })
                setPotTransportFlag(-1, 0);
                globalLogger.info(`所有复染检查完成,请收片,并按下"停止实验"`);
                motor.resetAllMotors();
                motor.enqueueMotorMovement('自检洗针洗玻片', {
                    offset: {
                        slideWashData: 3,
                        injectorWashData: {
                            type: 1,
                            waste: 1,
                            time: 7
                        }
                    }
                });
                // todo 添加全节点回零动作 allTransportFlag多一个阶段 结束自检
            }
        }
    }
}, 500);

// setTimeout(() => {
//     console.log(`skipStainingFlag: ${skipStainingFlag}`);
//     // console.log(`controlFlag.transportFlag :${controlFlag.allTransportFlag}`)
// }, 5000);
// 设置定时器 轮询各玻片位与水浴锅状态
// @note todoList
// todo 实验前要检查所有的玻片是否指定了实验程序,并计算所有试剂的余量是否充分

// * 水浴锅沿用当前的交互流程(通信要加上锅的编号),cmdFinishFlag阻塞改成每个主板独有一个FinishFlag,
// * 玻片位同样在当前交互流程的基础上改,需要与motor队列配合完成加液收片,cmdFinishFlag用于阻塞等待motor队列

const containerStatus = global.containerStatus;

// ----------------------------slide实验交互流程------------------------------------
//*  1.界面编辑好玻片位以后,开始实验,各个available的container状态切成waiting

//*  2.timer检测下位机是否空闲,若是,将优先级最高的一个WAITING的container状态切为BEGIN,发送指令给motor
//*  3.下位机开始滴液/冲洗/加热等步骤,操作完成后主动上报,container状态改为BUSY,更新finishTime
//*  4.处于BUSY状态的容器到finishTime后,发送step指令给下位机,container状态改为WAITING
//*  5.下位机上报操作完成,检查当前是否为实验最后一步,若是,container状态改为FINISH,进行第6步;否则,container状态改为WAITING,回到第2步

//*  6.FINISH状态的玻片数量达到一定程度后(根据分组统计),发送收片指令,container状态改为WAITING
//*  7.下位机上报收片完成,结束实验
/*** @note 查询玻片位状态
 * @description: 查询玻片位状态,由motor队列执行动作
 * @keyParam container[i].status        在controller里面,status控制该容器的状态,实验完成后的状态为FINISH
 * @keyParam cmdFinishData.FinishFlag   阻塞,使得motor队列同时只需要完成一项任务
 * @optimization 不同步骤的缓冲时间可以在系统设置里面配置(优先级低)
 */
function checkSlideStatus(container, pot) {
    // todo 不同玻片加液量可能会有不同,可以在offset里面配置

    // todo 可以根据试剂种类排序,这样可以取液时可以一次取多个玻片的量,减少洗针次数 优先级:中
    // todo 需要改动位置:   动作组dequeue时进行排序,计算取液量(按片计算给下位机就好) 
    // todo 方案1 动作组去掉取液洗针,缺点是这些动作组必须最高优先级(其实问题也不大),否则被中断后,试剂全乱
    // todo 方案2 把多个动作组合并成一个长动作组,缺点是附加偏移量要设计

    if (cmdQueue.size() === 0) {
        global.cmdQueueFlag = cmdFinishFlag.available; // * 这里的逻辑是,如果指令队列为空,则可以生成新指令(小心,必须执行完实验,才清空指令队列)
    }
    // * 检查正在执行实验步骤的容器
    for (let i = 0; i < container.length; i++) {
        if (container[i].experimentID !== -1 && container[i].experimentID !== null) {
            // * 为状态为WAITING的container生成命令,并入队
            if (container[i].status === containerStatus.WAITING) {
                if (cmdQueue.findIndex(container[i].id) === -1) { // * 检查该container是否已经有cmd在cmdQueue中
                    let randomNumber = Math.round(Math.random() * 89 + 10).toString();
                    let step = sqlMacros.sqlQuery('*', 'STEP', {
                            experimentID: container[i].experimentID,
                            sequence: container[i].sequence
                        }, 'AND')[0],
                        stepTime = step.stepTime,
                        stepReagent = step.stepReagent,
                        stepDose = step.dose, // * 相当于reagentNum
                        reagentContainerID = sqlMacros.sqlQuery('id', 'REAGENTCONTAINER', {
                            reagentNum: stepReagent,
                        }, 'AND');
                    container[i].stepTime = stepTime;
                    container[i].stepReagent = stepReagent;
                    if (reagentContainerID.length === 0) {
                        reagentContainerID = 1; // ! 测试用,非测试必须注释掉
                        logger.error('reagentContainerID is undefined');
                    } else {
                        reagentContainerID = reagentContainerID[0].id;
                    }
                    container[i].reagentContainerID = reagentContainerID;
                    if (container[i].priority !== -1 && container[i].priority !== undefined) {} else {
                        container[i].priority = 2;
                        if (parseInt(stepTime) <= 20) { container[i].priority = 5; } // * 短时长步骤需要优先处理
                    }
                    cmdQueue.enqueue({
                        containerID: container[i].id,
                        containerStatus: container[i].status,
                        experimentID: container[i].experimentID,
                        experimentName: container[i].experimentName,
                        sequence: container[i].sequence,
                        stepTime: container[i].stepTime,
                        stepReagent: stepReagent,
                        stepDose: stepDose,
                        reagentContainerID: container[i].reagentContainerID,
                        cmd_uuid: randomNumber, // ! uuid的生成有问题,偶发重复,暂时弃用
                        priority: container[i].priority, // 优先级,初始固定为2
                        paramType: 'experiment',
                    })
                } else {
                    if (![-1, null, undefined, ''].includes(container[i].finishTime)) {
                        let timeStatus = macroController.isTimeup(container[i].finishTime, container[i].priority);
                        if (timeStatus >= 3 && container[i].priority < macroController.timeupParams.maxPriority - 1) {
                            cmdQueue.editElementPropertyByID('priority', container[i].priority + 1, container[i].id);
                            sqlMacros.sqlMultiUpdate({ 'priority': container[i].priority + 1 }, 'CONTAINER', { 'id': container[i].id });
                            // * 超出缓冲时间,警告,提高优先级
                        }
                    } else {
                        // console.log(`element.finishTime is ${element.finishTime}`);
                    }
                    // 检查是否等待超时
                }
            }
        }
        // * 处于BUSY状态的容器到了finishTime后,对应处理
        if (container[i].status === containerStatus.BUSY) {
            let timeStatus = macroController.isTimeup(container[i].finishTime, container[i].priority);
            if (timeStatus >= 2) {
                let stepCount = sqlMacros.getTableCount('STEP', true, 'experimentID', container[i].experimentID);
                if (container[i].sequence < stepCount) {
                    // * 实验步骤时间到,sequence增加1,状态由BUSY切换成WAITING
                    sqlMacros.sqlMultiUpdate({
                            'sequence': container[i].sequence + 1,
                            'status': containerStatus.WAITING,
                        },
                        'CONTAINER', { 'id': container[i].id });
                    cmdQueue.popElementByProperty('containerID', container[i].id); // * 完成实验,清除实验指令
                    globalLogger.info(`${container[i].id}号玻片步骤${container[i].sequence}反应完成`);
                } else if (container[i].sequence === stepCount &&
                    !(container[i].experimentName.includes('DAB'))) { // * 二抗收尾时检查DAB设置
                    // * 实验步骤时间到,sequence增加1,状态由BUSY切换成WAITING
                    let dabConfig = {};
                    if (![null, 'null', undefined, ''].includes(pot[container[i].potGroupID - 1].DABConfig)) {
                        dabConfig.data = sqlMacros.sqlSelect('*', 'STEP', true,
                            'experimentName', pot[container[i].potGroupID - 1].DABConfig);
                        if (dabConfig.data.length === 0) {
                            logger.error('DAB实验未定义'); // ! 未定义DAB实验,需要在实验前检查并告警
                        } else {
                            dabConfig.data = dabConfig.data[0];
                            sqlMacros.sqlMultiUpdate({
                                    experimentID: dabConfig.data.experimentID,
                                    experimentName: dabConfig.data.experimentName,
                                    sequence: 1,
                                    status: containerStatus.WASH,
                                },
                                'CONTAINER', { 'id': container[i].id });
                            cmdQueue.popElementByProperty('containerID', container[i].id); // * 完成实验,清除实验指令
                            logger.info(`${container[i].id}号玻片反应完成,等待清洗`);
                            motor.enqueueMotorMovement('从玻片仓取出玻片清洗放回', {
                                offset: {
                                    slideID: container[i].id,
                                    potID: container[i].potGroupID,
                                    dabConfigData: dabConfig.data,
                                }
                            })
                        }
                    }
                } else {
                    // * 最后一步执行完,把experimentID置为-1,状态切换成FINISH
                    // * 最后一步执行完,状态切换成DAB
                    sqlMacros.sqlMultiUpdate({
                        experimentID: -1,
                        experimentName: '',
                        slideID: -1,
                        sequence: -1,
                        status: containerStatus.FINISH,
                        finishTime: -1,
                    }, 'CONTAINER', { 'id': container[i].id });
                    cmdQueue.popElementByProperty('containerID', container[i].id); // 完成实验,清除实验指令
                    globalLogger.info(`${container[i].id}号玻片实验完成,即将转运`);
                    // ! 实验最后一步完成后,应该是先去清洗玻片,再转运回水浴锅
                }
                sqlMacros.sqlMultiUpdate({ 'priority': 2 }, 'CONTAINER', { 'id': container[i].id }); // 设置下一步骤/转运的优先级
            }
        }
    }

    // * 机械臂空闲,且无BEGIN状态的element,则查询处于WAITING状态,优先级最高的element,设置为BEGIN状态
    if (global.cmdQueueFlag === cmdFinishFlag.available && cmdQueue.size() > 0 &&
        cmdQueue.findElementByProperty('containerStatus', containerStatus.BEGIN) === null && !motor.getBlockFlag()) {
        let waitingElements = cmdQueue.filter((element) => {
            return element.containerStatus === containerStatus.WAITING;
        });
        if (waitingElements.length > 0) {
            // * findElement是状态为waiting的优先级最高的element
            let findElement = waitingElements[0];
            for (let i = 0; i < waitingElements.length; i++) { // * 确认一下是顺序还是倒序搜索,先进先出的话应该是顺序
                if (waitingElements[i].priority > findElement.priority) {
                    findElement = waitingElements[i];
                }
            }
            cmdQueue.editElementPropertyByID('containerStatus', containerStatus.BEGIN, findElement.containerID);
            global.cmdQueueFlag = cmdFinishFlag.processing;
            sqlMacros.sqlMultiUpdate({
                    'status': containerStatus.BEGIN,
                    'priority': 2,
                    'finishTime': -1,
                },
                'CONTAINER', { 'id': findElement.containerID });
            findElement.containerStatus = containerStatus.BEGIN;
            if (findElement.stepReagent.includes("DAB")) {
                if (findElement.experimentName === '增强DAB' && findElement.sequence > 1) {
                    findElement.slideWashData = 3; // * 第二步增强DAB的清洗,排液到废液A(有毒)                    
                } else {
                    findElement.slideWashData = 4;
                }
                findElement.injectorWashData = {
                    type: 1,
                    waste: 1,
                    time: 3,
                }
                // findElement.injectorWashData = 1;
            } else {
                findElement.slideWashData = 4;
                // findElement.injectorWashData = 2;
                findElement.injectorWashData = {
                    type: 1,
                    waste: 2,
                    time: 3,
                }
            }
            // if (['DAB', '增强DAB', 'H2O2阻断剂', '二抗'].includes(findElement.stepReagent)) {
            //     findElement.injectorWashData = {
            //         type: 0,
            //         waste: 2,
            //         time: 1,
            //     };
            //     if (findElement.experimentName === '增强DAB' && findElement.sequence > 1) {
            //         findElement.injectorWashData.waste = 1;
            //     }
            // }
            motor.enqueueMotorMovement('从玻片仓取出玻片清洗再加液', findElement);
            logger.info(`motor执行 从玻片仓取出玻片清洗再加液 containerID:${findElement.containerID},sequence:${findElement.sequence}`);
            // logger.warn(cmdQueue.getQueue())
            motor.movementStatus.postMovement = motor.movementStatus.currMovement;
            motor.movementStatus.currMovement.name = '从玻片仓取出玻片清洗再加液';
        }
    }
    // ! 执行完实验后有概率出现状态未清除的情况,需要排查各标志位
    // ! 目前排查出是FinishFlag在motor更新状态时被错误使用,FinishFlag只能用于加液动作组,转运不能用

    // motor队列完成动作组后返回信息
    // 完成指令,把状态改为containerStatus.BUSY,dequeue队首元素
    if (global.cmdQueueFlag === cmdFinishFlag.waiting &&
        cmdQueue.size() > 0 && !motor.getBlockFlag()) {
        let element = cmdQueue.findElementByProperty('containerStatus', containerStatus.BEGIN); //目的是排出刚执行完的元素
        if (element !== undefined && element !== null) {
            // * dequeue的元素代表孵化操作完成,把状态设置为busy,更新finish_time
            let finishTime = macroController.getFinishTime(element.stepTime, 'second'); // ! 测试时用second,实验中孵化默认minute 
            sqlMacros.sqlMultiUpdate({
                'status': containerStatus.BUSY,
                'finishTime': finishTime,
            }, 'CONTAINER', { 'id': element.containerID });
            cmdQueue.editElementPropertyByID('containerStatus', containerStatus.BUSY, element.containerID);
            global.cmdQueueFlag = cmdFinishFlag.available;
            globalLogger.info(`${element.containerID}号玻片加入${element.stepReagent}`);
            logger.warn(`motor完成步骤,进入BUSY状态,containerID:${element.containerID},sequence:${element.sequence}`);
            logger.warn(cmdQueue.getQueue());
        } else if (element !== null) {
            logger.info('未找到队列元素');
            logger.error(cmdQueue.getQueue());
            //TODO: 要做异常处理,未找到与下位机返回的cmd_uuid相符合的命令
        }
    }
}

// ----------------------------抗原修复实验交互流程------------------------------------
//*  1.界面编辑好水浴锅实验以后,点击开始实验,各个AVAILABLE的container状态切成WAITING
//*  2.状态WAITING的container,生成通信指令,发送串口消息,更新container状态为BEGIN
//*  3.状态BEGIN的container,生成通信指令,发送串口消息,更新container状态为BEGIN

/***  @note 查询各主板状态
 * @description: 查询水浴锅状态，根据实验信息发指令
 * @description: 向总线发送查询信息,接收到命令的从机返回自身状态
 * @keyParam     pot[i].status    在controller里面,status控制该容器的状态,实验完成后的状态为FINISH
 * @optimization 不同步骤的缓冲时间可以在系统设置里面配置(优先级低)
 */
function checkPotStatus(pot) {
    for (let i = 0; i < pot.length; i++) {
        if (pot[i].status === containerStatus.AVAILABLE) {}
        if (pot[i].status === containerStatus.SCANLABEL && controlFlag.pot[i + 1].scanLabelFlag === false) {
            motor.scanPotSlide(pot[i].id);
            controlFlag.pot[i + 1].scanLabelFlag = true;
        }
        if (pot[i].status === containerStatus.WAITING) {
            // * 对应主板空闲,且容器设置了实验,状态为WAITING,则生成实验指令并发送给主板
            let step = sqlMacros.sqlQuery('*', 'STEP', {
                experimentID: pot[i].experimentID,
                sequence: pot[i].sequence
            }, 'AND')[0];

            pot[i].stepTime = step.stepTime;
            pot[i].stepReagent = (step.stepReagent === undefined) ? '' : step.stepReagent;
            pot[i].stepTemperature = (step.temperature === undefined) ? '' : step.temperature;
            pot[i].reagentID = (step.reagentID === undefined) ? 0 : step.reagentID;
            pot[i].status = containerStatus.BEGIN;
            pot[i].startTime = macroController.getNow();
            sqlMacros.sqlMultiUpdate({
                'status': containerStatus.BEGIN,
                'startTime': pot[i].startTime,
                'stepTime': step.stepTime,
                'stepReagent': step.stepReagent,
                'stepTemperature': step.temperature,
            }, 'POT', { 'id': pot[i].id });

            let stepCmd = stepToPotCommand(pot[i], step); // * 检查试剂余量
            if (step.sequence === 1) { // 第一步触发关盖
                motor.enqueueMotorMovement("修复盒关盖", {
                    potGroupID: pot[i].id,
                    stepCmd: stepCmd
                });
                logger.info(motor.motorMovementQueue.getQueue());
            } else {
                serial.protocol.sendPackedMsg(stepCmd, serial.boards[`board${pot[i].id}`]); // * 发送串口消息
            }
            // * 发送完指令后,切换状态到BEGIN
        }

        if (pot[i].status === containerStatus.BEGIN) {
            // * 等待下位机回复,回复正常则更新数据库,切换状态到BUSY(在serial那边收到数据会改container[i].containerStatus)          
            let startTime = pot[i].startTime;
            if (macroController.isTimeup(startTime, 6) === 4) {
                logger.warn('下位机超时,指令是否已执行？'); // * 这里也设置一个等待超时,时限通常为实际执行用时 + 120s
            }
        }

        if (pot[i].status === containerStatus.BUSY) {
            let timeStatus = macroController.isTimeup(pot[i].finishTime, 1);
            if (timeStatus >= 2) {
                logger.warn(`执行修复步骤,timeStatus:${timeStatus}`);
                // * 实验时间到
                let stepCount = sqlMacros.getTableCount('STEP', true, 'experimentID', pot[i].experimentID);
                if (pot[i].sequence < stepCount) {
                    sqlMacros.sqlMultiUpdate({
                            'sequence': pot[i].sequence + 1,
                            'status': containerStatus.WAITING
                        },
                        'POT', { 'id': pot[i].id });
                    logger.warn(`步骤时间到,containerID:${pot[i].id},sequence:${pot[i].sequence}`);
                    globalLogger.info(`${pot[i].id}号修复缸完成步骤${pot[i].sequence}`);
                } else {
                    let experiment = sqlMacros.sqlQuery('*', 'EXPERIMENT', {
                        id: pot[i].experimentID,
                    }, 'AND');
                    if (experiment.length > 0) {
                        if (experiment[0].type === '复染') { setPotTransportFlag(pot[i].id, 5); } else {
                            motor.enqueueMotorMovement("修复盒开盖", {
                                potID: pot[i].id
                            }); // * 修复完成执行开盖
                        }
                        sqlMacros.sqlMultiUpdate({
                            status: containerStatus.FINISH,
                            finishTime: '',
                            experimentName: '',
                            experimentID: '-1',
                            sequence: 1,
                            level: 0
                        }, 'POT', { 'id': pot[i].id }); // * 实验完成,清空相关变量,状态设置为FINISH
                        logger.warn(`实验全部完成,containerID:${pot[i].id},sequence:${pot[i].sequence}`);
                        globalLogger.info(`${pot[i].id}号修复缸完成实验,即将转运`);
                        // * 水浴锅完成时,启动取片步骤
                    }
                }
            }
        }
        // * 只需要以containerStatus作为标志位就好了,因为主板单独控制一个锅,不需要队列
    }
}

/***
 * @description: 实验步骤转指令
 * @param {*} pot   水浴锅
 * @param {*} step 实验步骤
 * @return {*}
 */
function stepToPotCommand(pot, step) {
    let cmdStr = ''; //返回值
    let reagentID = pot.reagentID;
    let reagentContainerID = '00';
    // todo 如果未搜索到试剂id 会报sql错误  比如:添加步骤选择试剂后又删除了该试剂

    if (pot.level === 3) { // * 排空,优先级最高
        sqlMacros.sqlMultiUpdate({
            'reagentID': 10,
            'level': 3,
            'stepTemperature': 0,
            'stepTime': 0
        }, 'POT', 'id', pot.id);
        step.temperature = 0;
        step.time = 0;
        pot.level = 3;
        reagentID = 10
    } else {
        let reagent = sqlMacros.sqlSelect('id', 'REAGENT', true, 'reagentNum', pot.stepReagent)[0];
        if (pot.stepReagent != '无') { // * 烤片液位:01 加液
            // let reagentContainer = sqlMacros.sqlSelect('id', 'COMMONREAGENT', true, 'reagentNum', pot.stepReagent)[0];
            // if (reagentContainer.length > 0) {
            //     // console.log(`level:${reagentContainer.level}`); // todo 根据液位判断
            //     reagentContainerID = reagentContainer.id;
            // }
            // * 这里进行判断 实验步骤所需的试剂是否存在于COMMONREAGENT中，余量是否足够

            let stepArray = sqlMacros.sqlSelect('*', 'STEP', true, 'experimentID', pot.experimentID);
            if (['TBS', '纯水', 'H2O2阻断剂', '酸性修复液', '碱性修复液'].includes(pot.stepReagent)) {
                pot.level = 1; // * 现在2是加液并回收上次试剂,1是加液不回收 22/07/07
            } else { pot.level = 2; }
            if (step.sequence === stepArray.length && (pot.stepReagent === 'TBS' || pot.stepReagent.includes("修复液"))) {
                pot.level = 5; // * 最后一步是TBS的话,不排液,防止干片,染色实验完成后排液(二代机),三代机分出片缸,转运后排液即可  22/07/29  
            }
            sqlMacros.sqlMultiUpdate({ 'level': pot.level, reagentID: reagent.id }, 'POT', { 'id': pot.id });
        } else if (pot.stepReagent === '无') { // * 烤片液位:02 排液
            sqlMacros.sqlMultiUpdate({ 'level': 3, reagentID: reagent.id }, 'POT', { 'id': pot.id });
            pot.level = 3;
        } // 烤片步骤没有试剂,默认reagentID为"00"
    }

    cmdStr = serial.protocol.getCmdStr(pot.id, serial.protocol.setContainerStatusCmd,
        [reagentID, serial.prefixInteger(pot.level, 2), step.temperature, 0, step.stepTime]); // * stepTime单位是秒,需要在前一位数据加个0占位
    return cmdStr;
}

/***
 * @description: 实验步骤转指令
 * @param {*} containerID   容器ID
 * @param {*} experimentID  实验ID
 * @param {*} sequence      步骤编号
 * @return {*}
 * TODO: 重新匹配step_type
 */
function step2command(containerID, experimentID, sequence) {
    //  根据实验步骤，整理出对应的参数指令，调用通信函数
    let cmdStr = ''; //返回值
    let stepJson = sqlMacros.sqlQuery('*', 'STEP', {
        experimentID: experimentID,
        sequence: sequence
    }, 'AND')[0];

    //  containerID 小于10的话,要在前面加'0' 
    let containerData = sqlMacros.sqlSelect('*', 'CONTAINER', true, 'id', containerID)[0];
    let stepReagent = sqlMacros.sqlSelect('*', 'REAGENT', true, 'name', stepJson.stepReagent)[0];
    let reagentID = (stepReagent === undefined) ? 0 : stepReagent.id;
    let reagentContainerID = '00';
    // todo 如果未搜索到试剂id 会报sql错误  比如:添加步骤选择试剂后又删除了该试剂

    if (reagentID != null) {
        let reagentContainer = sqlMacros.sqlSelect('id', 'REAGENTCONTAINER', true, 'reagentID', reagentID)[0];
        if (reagentContainer.length > 0) {
            // console.log(`level:${reagentContainer.level}`); // * 根据液位判断 level的含义为百分比或是试剂重量
            reagentContainerID = reagentContainer.id;
        }
        // * 这里进行判断 实验步骤所需的试剂是否存在于REAGENTCONTAINER中，余量是否足够
        console.log(`reagentContainerID: ${reagentContainerID}`);
    } else {
        reagentID = '00';
    } // 烤片步骤没有试剂,默认reagentID为"00"

    if (containerData.type === 'pot') {
        let level = (reagentID === '00') ? '00' : '01';
        cmdStr = serial.protocol.getCmdStr(serial.protocol.setContainerStatusCmd,
            [containerID.toString(), reagentID, level, stepJson.temperature]);
    } else if (containerData.type === 'slide') {
        if (stepJson['stepType'] === '滴加试剂') {
            if (true) {
                return serial.protocol.getCmdStr(serial.protocol.addReagent2SlideCmd,
                    [reagentContainerID, containerID]);
                // * 这里的reagentID实际是下位机内对试剂位的编号(就是reagentContainer的id)
            } // todo 加判断,试剂是否有余量,同名试剂优先选取序号较小的 以后开机要计算所有试剂余量是否足够
        } else if (stepJson['stepType'] === '冲洗') {
            //reagentID这里有水\PBS\吹气三种选择 要在sql表中有体现,要和下位机有约定 PS:通用试剂在reagent表内是一条数据
            return serial.protocol.getCmdStr(4, serial.protocol.flushSlideCmd,
                [containerID, reagentID]);
        } else {
            return '非法指令类型';
        }
    }
    return cmdStr;
}

/*** @note 计算试剂消耗量
 * @description: 
 * @return {*}
 */
function getReagentCost(slide, reagentContainer) {
    let step = sqlMacros.sqlSelect('*', 'STEP');
    let reagentCost = {};
    slide.forEach(element => {
        if (element.experimentID !== -1) {
            step.forEach(stepElement => {
                if (stepElement.experimentID === element.experimentID) {
                    if (reagentCost[stepElement.stepReagent] !== undefined) {
                        reagentCost[stepElement.stepReagent] += parseInt(stepElement.dose);
                    } else {
                        reagentCost[stepElement.stepReagent] = parseInt(stepElement.dose);
                    }
                }
            });
        }
    }); // * 计算出本轮实验消耗试剂量
    Object.keys(reagentCost).forEach(reagentElement => {
        console.log(`${reagentElement}:${reagentCost[reagentElement]}`);
        reagentContainer.forEach(element => {
            if (reagentElement === element.reagentNum) {
                reagentCost[reagentElement] -= parseInt(element.level); // ! 这里的level是试剂的余量,必须先完成测定再进行计算,否则结果为NaN
            }
        });
    });
    console.log(reagentCost);
    return reagentCost;
}

// todo: 试剂瓶液位检测以及通用试剂液位检测
/***
 * @description: 检测试剂总量是否足够 检查时机:所有转运完成后自检所有ReagentContainer
 * @param {Number} mode 模式
 */
function checkReagentLevel(mode) {
    // ! 需要考虑多瓶相同试剂的情况
    // 抗原修复时,右手进行液面检测
    let reagentContainer = sqlMacros.sqlSelect('*', 'REAGENTCONTAINER');
    let reagentCost = {};

    // * 查表得出对应的检测高度(高度向上取整,通过实测得出1-15ml的高度)
    // 根据标志位判断是否添加动作组
    if (mode === 1) {
        reagentContainer.forEach(element => {
            motor.enqueueMotorMovement("试剂瓶液面检测", {
                reagentID: element.id,
            })
        });
    } else if (mode === 2) {
        // * 动作组完成,计算本轮实验的消耗总量

    }
    // 加入液面检测动作组
}


/*** @note 全局暂停
 * @description: 
 * @return {*}
 */
function pauseAllWork() {

}



const controller = {
    statusTimer,
    checkSlideStatus,
    setControlFlag,
    setPotTransportFlag,
    setPotEnableFlag,
    setScanLabelFlag,
    step2command,
    containerStatus,

    cmdQueue,
    editCmdElementByID,
    findCmdElement,
    controlFlag,

}
module.exports = controller;